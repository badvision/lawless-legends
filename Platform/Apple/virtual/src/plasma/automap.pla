///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2017 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
//////////////////f/////////////////////////////////////////////////////////////////////////////////

include "gamelib.plh"
include "globalDefs.plh"
include "playtype.plh"
include "gen_modules.plh"

const MAP_TOP     = 11 // lines
const MAP_LEFT    = 2  // bytes

const SCREEN_ROWS = 21
const SCREEN_COLS = 36

const SECTION_WIDTH_2D  = 22
const SECTION_HEIGHT_2D = 23

struc MapSection
  byte b_mapNum
  word p_map
  byte b_tilesetNum
  word p_tileset
  byte b_visible
  word w_x0   // upper-left coord of map in global space
  word w_y0
  word w_x1   // bottom-right coord of map (exclusive) in global space
  word w_y1
  byte b_sx   // clipped screen coordinate
  byte b_sy
  byte b_ox   // clipped offset within map to display
  byte b_oy
  byte b_cw   // clipped size within map to display
  byte b_ch
end

const SECT_BUF_SIZE = MAX_MAP_SECT * MapSection

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the header.
predef _automap_show()#1
word[] funcTbl = @_automap_show

word tilePtrs[40]
byte blankTile[9]

word screenX0, screenY0, screenX1, screenY1

byte nHorzSects
byte sectionBuf[SECT_BUF_SIZE]
word pLastSection

///////////////////////////////////////////////////////////////////////////////////////////////////
// Definitions used by assembly code
asm _defs
!convtab "../../include/hiBitAscii.ct"
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"
!source "../../include/fontEngine.i"
tmp         = $2   ; length 2
pTmp        = $4   ; length 2
tilePtrs    = $6   ; length 2
pTile       = $8   ; length 2
pBlank      = $A   ; length 2
hibits      = $C   ; length 1
nTiles      = $D   ; length 1
prevBits    = $E   ; length 1
unused0F    = $F   ; length 1
linePtrs    = $10  ; length 2*8 = 16
ysav        = $34  ; length 1
end

///////////////////////////////////////////////////////////////////////////////////////////////////
asm drawSlice(pBlank, pScreen, nTiles, tilePtrs)#0
  +asmPlasmNoRet 4
  sta tilePtrs
  sty tilePtrs+1
  lda evalStkL+1,x
  sta nTiles
  lda evalStkL+2,x
  sta pTmp
  lda evalStkH+2,x
  sta pTmp+1
  lda evalStkL+3,x
  sta pBlank
  lda evalStkH+3,x
  sta pBlank+1
  ; Grab the line pointers for all 8 lines
  ldx #0
- lda pTmp
  sta linePtrs,x
  inx
  lda pTmp+1
  sta linePtrs,x
  inx
  jsr NextScreenLine
  cpx #16
  bne -
  ; Process one tile
.tile
  ldy #0
  lda (tilePtrs),y
  sta pTile
  iny
  lda (tilePtrs),y
  sta pTile+1
  lda tilePtrs
  clc
  adc #2
  sta tilePtrs
  bcc +
  inc tilePtrs+1
+ dey
  lda (pTile),y
  sta hibits
  sta (pBlank),y   ; if next tile is blank, match hi bits of this tile
  iny
  ldx #0
  lda linePtrs
  lsr
  bcs .odd
.even
  lda (pTile),y
  iny
  asl
  ror prevBits
  lsr hibits
  ror
  sta (linePtrs,x)
  inc linePtrs,x
  inx
  inx
  cpx #16
  bne .even
  beq .next   ; always taken
.odd
  lda (pTile),y
  iny
  lsr prevBits
  rol
  asl
  lsr hibits
  ror
  sta (linePtrs,x)
  inc linePtrs,x
  inx
  inx
  cpx #16
  bne .odd
.next
  dec nTiles
  bne .tile
  rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
asm showCursor(color, pScreen)#0
  +asmPlasmNoRet 2
  sta pTmp
  sty pTmp+1
  lda evalStkL+1,x
  ldx #8
- ldy #0
  sta (pTmp),y
  pha
  jsr NextScreenLine
  pla
  dex
  bne -
  rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayRow3D(pScreen, mapRowData, tileTrans, pSmallTiles, width)#0
  byte x, mapRaw, tileNum
  for x = 0 to width-1
    mapRaw = ^(mapRowData + x) & $1F
    if mapRaw
      tileNum = ^(tileTrans + ((mapRaw - 1) << 1))
      tilePtrs[x] = pSmallTiles + ((tileNum-1) * 9)  // 9 bytes per reduced tile in the tileset
    else
      tilePtrs[x] = @blankTile
    fin
  next
  drawSlice(@blankTile, pScreen, width, @tilePtrs)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayRow2D(pScreen, mapRowData, pSmallTiles, width)#0
  byte x, mapRaw, tileNum
  for x = 0 to width-1
    tileNum = ^(mapRowData + x) & $3F
    if tileNum
      tilePtrs[x] = pSmallTiles + ((tileNum-1) * 9)  // 9 bytes per reduced tile in the tileset
    else
      tilePtrs[x] = @blankTile
    fin
  next
  drawSlice(@blankTile, pScreen, width, @tilePtrs)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def make3DSection(pSection)#0
  // Record the map data (it's already loaded for 3D display)
  pSection->b_mapNum = mapNum
  pSection=>p_map = pCurMap

  // Record the tile set number
  pSection->b_tilesetNum = ^(pSection=>p_map + 3)
  pSection=>p_tileset = NULL

  // Record the coordinates
  pSection=>w_x0 = 0
  pSection=>w_y0 = 0
  pSection=>w_x1 = totalMapWidth
  pSection=>w_y1 = totalMapHeight
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def make2DSection(pSection, sh, sv)#0
  // Record the map data (the top-left segment is already loaded)
  pSection->b_mapNum = mapNum + (sv*nHorzSects) + sh
  pSection=>p_map = (pSection->b_mapNum == mapNum) ?? pCurMap :: NULL

  // Tileset will be calculated later
  pSection->b_tilesetNum = 0
  pSection=>p_tileset = NULL

  // Record the coordinates
  pSection=>w_x0 = sh * SECTION_WIDTH_2D
  pSection=>w_y0 = sv * SECTION_HEIGHT_2D
  pSection=>w_x1 = pSection=>w_x0 + SECTION_WIDTH_2D
  pSection=>w_y1 = pSection=>w_y0 + SECTION_HEIGHT_2D
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def printSection(pSection)#0
  printf1("Sect %d: ", (pSection - @sectionBuf) / MapSection)
  printf2("%d/%d - ", pSection=>w_x0, pSection=>w_y0)
  printf2("%d/%d; ", pSection=>w_x1, pSection=>w_y1)
  printf1("vis=%d ", pSection->b_visible)
  if pSection->b_visible
    printf2("scrn=%d/%d ", pSection->b_sx, pSection->b_sy)
    printf2("off=%d/%d ", pSection->b_ox, pSection->b_oy)
    printf2("clip=%dw/%dh", pSection->b_cw, pSection->b_ch)
  fin
  puts(".\n")
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def prepSections#0
  word pSection
  word x0, y0, x1, y1
  byte anyQueued

  anyQueued = FALSE
  mmgr(START_LOAD, curMapPartition)
  for pSection = @sectionBuf to pLastSection step MapSection
    x0 = max(screenX0, pSection=>w_x0)
    y0 = max(screenY0, pSection=>w_y0)
    x1 = min(screenX1, pSection=>w_x1)
    y1 = min(screenY1, pSection=>w_y1)
    if x0 < x1 and y0 < y1
      pSection->b_visible = TRUE
      pSection->b_sx = x0 - screenX0
      pSection->b_sy = y0 - screenY0
      pSection->b_ox = x0 - pSection=>w_x0
      pSection->b_oy = y0 - pSection=>w_y0
      pSection->b_cw = x1 - x0
      pSection->b_ch = y1 - y0
      if !pSection=>p_map
        // Note, this only happens in 2D mode (3D has only one map, which always stays loaded)
        pSection=>p_map = mmgr(QUEUE_LOAD, (pSection->b_mapNum)<<8 | RES_TYPE_2D_MAP)
        anyQueued = TRUE
      fin
    else
      pSection->b_visible = FALSE
    fin
  next

  // Make sure all maps are loaded before we attempt to figure out their tilesets
  if anyQueued
    mmgr(FINISH_LOAD, 0)
    mmgr(START_LOAD, curMapPartition)
  fin

  // Load all the tilesets
  for pSection = @sectionBuf to pLastSection step MapSection
    if pSection->b_visible and !pSection=>p_tileset
      if !pSection->b_tilesetNum
        // This part only happens in 2D mode (a 3D section have tileset filled in at construction)
        pSection->b_tilesetNum = ^(pSection=>p_map + 4)
      fin
      pSection=>p_tileset = mmgr(QUEUE_LOAD, (pSection->b_tilesetNum)<<8 | RES_TYPE_TILESET)
    fin
  next

  mmgr(FINISH_LOAD, 0)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def freeSections#0
  word pSection
  for pSection = @sectionBuf to pLastSection step MapSection
    if pSection=>p_map and pSection=>p_map <> pCurMap
      mmgr(FREE_MEMORY, pSection=>p_map)
      pSection=>p_map = NULL
    fin
    if pSection=>p_tileset
      mmgr(FREE_MEMORY, pSection=>p_tileset)
      pSection=>p_tileset = NULL
    fin
  next
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displaySection3D(pSection)#0
  word pSmallTiles, tileTrans, mapData, rowData, pScreen
  byte nTextures, y, rowSize

  // Figure out where the small tiles reside (at the end of the full size tiles)
  pSmallTiles = pSection=>p_tileset + 1 + ((^(pSection=>p_tileset)) << 5)

  // Extract significant pointers from the map blob
  rowSize = ^(pSection=>p_map)
  tileTrans = pSection=>p_map + 4
  nTextures = 0
  while ^(tileTrans + (nTextures<<1))
    nTextures++
  loop
  mapData = tileTrans + (nTextures*3) + 2  // *2 for tilenum+texnum, *1 for texture flags, 2 for zero-terms

  // Display each visible row
  for y = 1 to pSection->b_ch  // offset is 1 to skip over sentinel row
    // The +1's below are to skip over the sentinel row and column that 3D maps have
    rowData = mapData + ((y + pSection->b_oy) * rowSize) + pSection->b_ox + 1
    // The << 3 below is because each row is 8 screen lines
    pScreen = getScreenLine(((y + pSection->b_sy) << 3) + (MAP_TOP-8)) + MAP_LEFT + pSection->b_sx
    displayRow3D(pScreen, rowData, tileTrans, pSmallTiles, pSection->b_cw)
  next
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displaySection2D(pSection)#0
  word pSmallTiles, rowData, pScreen
  byte y, rowSize

  // Figure out where the small tiles reside (at the end of the full size tiles)
  pSmallTiles = pSection=>p_tileset + 1 + ((^(pSection=>p_tileset)) << 5)

  // Display each visible row
  for y = 0 to pSection->b_ch-1
    // The +6 below is to skip over the 2D map's header
    rowData = pSection=>p_map + 6 + ((y + pSection->b_oy) * SECTION_WIDTH_2D) + pSection->b_ox
    // The << 3 below is because each row is 8 screen lines
    pScreen = getScreenLine(((y + pSection->b_sy) << 3) + MAP_TOP) + MAP_LEFT + pSection->b_sx
    displayRow2D(pScreen, rowData, pSmallTiles, pSection->b_cw)
  next
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displaySections#0
  word pSection
  for pSection = @sectionBuf to pLastSection step MapSection
    //printSection(pSection)
    if pSection->b_visible
      if mapIs3D
        displaySection3D(pSection)
      else
        displaySection2D(pSection)
      fin
    fin
  next
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def setup3D#0
  make3DSection(@sectionBuf)
  pLastSection = @sectionBuf
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def setup2D#0
  word pSection
  byte nVertSects, sh, sv
  nHorzSects = (totalMapWidth + SECTION_WIDTH_2D - 1) / SECTION_WIDTH_2D
  nVertSects = (totalMapHeight + SECTION_HEIGHT_2D - 1) / SECTION_HEIGHT_2D
  pLastSection = @sectionBuf + (((nVertSects * nHorzSects) - 1) * MapSection)
  sh = 0
  sv = 0
  for pSection = @sectionBuf to pLastSection step MapSection
    make2DSection(pSection, sh, sv)
    sh++
    if sh == nHorzSects
      sh = 0
      sv++
    fin
  next
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def centerScreen#0
  word x, y
  getPos(@x, @y)
  screenX0 = x - (SCREEN_COLS>>1)
  screenY0 = y - (SCREEN_ROWS>>1)
  screenX1 = screenX0 + SCREEN_COLS
  screenY1 = screenY0 + SCREEN_ROWS
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def cursorWait#1
  word x, y, i
  byte phase, color
  getPos(@x, @y)
  phase = 0
  while ^kbd < 128
    when phase
      is 0; color = $AA; break
      is 1; color = $D5; break
      is 2; color = $AA; break
      is 3; color = $D5; break
      is 4; color = $FF; break
    wend
    if x >= screenX0 and x < screenX1 and y >= screenY0 and y < screenY1
      showCursor(color, getScreenLine(((y-screenY0)<<3)+MAP_TOP) + (x-screenX0+MAP_LEFT))
    fin
    i = 0
    while i < 200 and ^kbd < 128
      i++
    loop
    phase = (phase+1) % 5
  loop
  i = ^kbd
  ^kbdStrobe
  return charToUpper(i & $7F)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def showTitle#0
  setWindow(2, 12, 98, 182) // Top, Bottom, Left, Right
  clearWindow
  rawDisplayStr("^V001")
  centerStr(global=>s_mapName, 84)
  setBigWindow
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _automap_show()#1
  byte key

  // Clear out the blank tile buffer
  memset(@blankTile, 0, 9)

  // Setup phase
  if mapIs3D; setup3D; else setup2D; fin
  centerScreen
  setBigWindow
  clearWindow
  showTitle

  repeat
    setWindow(BIGWIN_TOP+2, BIGWIN_BOTTOM, BIGWIN_LEFT, BIGWIN_RIGHT)
    clearWindow

    // Calculate visiblity and load maps+tilesets
    //printf2("Screen: %d/%d - ", screenX0, screenY0)
    //printf2("%d/%d\n", screenX1, screenY1)
    prepSections

    // Display everything visible
    displaySections

    // Free memory
    freeSections

    // Now allow the player to scroll the map
    key = cursorWait
    when key
      is 'W'; is 'I'; is 11
        screenY0 = screenY0 - 8   // north
        screenY1 = screenY1 - 8
        break
      is 'D'; is 'L'; is 21
        screenX0 = screenX0 + 8   // east
        screenX1 = screenX1 + 8
        break
      is 'S'; is 'X'; is 'K'; is ','; is 10
        screenY0 = screenY0 + 8   // south
        screenY1 = screenY1 + 8
        break
      is 'A'; is 'J'; is 8
        screenX0 = screenX0 - 8   // west
        screenX1 = screenX1 - 8
        break
    wend
  until key == 27 or key == 'Q' or key == '-' // esc or Q or - to exit
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
