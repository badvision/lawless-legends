///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2015 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
///////////////////////////////////////////////////////////////////////////////////////////////////

include "gamelib.plh"
include "globalDefs.plh"
include "playtype.plh"
include "diskops.plh"
include "gen_modules.plh"
include "gen_players.plh"

const RWTS_SEEK  = 0
const RWTS_READ  = 1
const RWTS_WRITE = 2

const RWTS_DRV1  = 0
const RWTS_DRV2  = $80

const RWTS_RDWRPART = (0<<8)
const RWTS_OPENDIR  = (1<<8)

const LOAD_SAVE_BUF = $5000

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the the header.
predef _saveGame, _loadGame, _newOrLoadGame
word[] funcTbl = @_saveGame, @_loadGame, @_newOrLoadGame

byte[] game1_filename = "GAME.1.SAVE"

///////////////////////////////////////////////////////////////////////////////////////////////////
// Definitions used by assembly code
asm __defs

; Use hi-bit ASCII for Apple II
!convtab "../../include/hiBitAscii.ct"

; Headers
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"

; Optional debug printing support
DEBUG   = 0

; General use
tmp         = $2
pTmp        = $4

; ProRWTS equates
proRWTS     = $D000       ;over in aux LC (in bank 1 just like mem mgr)

status      = $3          ;returns non-zero on error
auxreq      = $a          ;set to 1 to read/write aux memory, else main memory is used
sizelo      = $6          ;set if enable_write=1 and writing, or reading, or if enable_seek=1 and seeking
sizehi      = $7          ;set if enable_write=1 and writing, or reading, or if enable_seek=1 and seeking
reqcmd      = $2          ;set (read/write/seek) if enable_write=1 or enable_seek=1
                          ;if allow_multi=1, bit 7 selects floppy drive in current slot
                          ;  (clear=drive 1, set=drive 2) during open call
                          ;bit 7 must be clear for read/write/seek on opened file
ldrlo       = $E          ;set to load address if override_adr=1
ldrhi       = $F          ;set to load address if override_adr=1
namlo       = $C          ;name of file to access
namhi       = $D          ;name of file to access

cmdseek     = 0           ;requires enable_seek=1
cmdread     = 1           ;requires enable_write=1
cmdwrite    = 2           ;requires enable_write=1

end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Params: cmd | open<<8, filename, addr, size. Returns: status (for open only)
//   cmd: 
asm callProRWTS
    +asmPlasm 4
    ; Params come to us from PLASMA in reverse order
    sta setAuxZP
    sta sizelo
    sty sizehi

    sta clrAuxZP
    lda evalStkL+1,x
    ldy evalStkH+1,x
    sta setAuxZP
    sta ldrlo
    sty ldrhi

    sta clrAuxZP
    lda evalStkL+2,x
    ldy evalStkH+2,x
    sta setAuxZP
    sta namlo
    sty namhi

    sta clrAuxZP
    lda evalStkL+3,x
    ldy evalStkH+3,x
    sta setAuxZP
    sta reqcmd
    lda #0
    sta auxreq

    bit setLcRW+lcBank1
    bit setLcRW+lcBank1
    tya
    bne +
    jsr proRWTS
    clc
    bcc ++
+   jsr proRWTS+3
++  lda status
    ldy #0
    bit setLcRW+lcBank2
    bit setLcRW+lcBank2
    sta clrAuxZP
    rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// The following only used for speed testing
//asm readNoSlotClock  // param: dstBuf (will receive 8 BCD bytes)
//!zone {
//  +asmPlasm 1
//  ; record dst ptr
//  sta tmp
//  sty tmp+1
//  ; obtain a pointer to our little table of magic values
//  lda #$60
//  sta pTmp
//.base = *+2
//  jsr pTmp
//  tsx
//  dex
//  dex
//  txs
//  pla
//  sta pTmp
//  pla
//  sta pTmp+1
//  ldy #<(.tbl - .base)
//  ; record state of slot ROM, then turn on C3 ROM
//  sei
//  lda $CFFF
//  pha
//  sta $C300
//  lda $C304
//  ldx #8
//.wr1:
//  lda (pTmp),y
//  sec
//  ror
//.wr2:
//  bcs +
//  bit $C300
//  bcc ++
//+ bit $C301
//++ lsr
//  bne .wr2
//  iny
//  dex
//  bne .wr1
//  ldy #7
//.rd1:
//  ldx #8
//.rd2:
//  lda $C304
//  lsr
//  ror pTmp
//  dex
//  bne .rd2
//  lda pTmp
//  sta (tmp),y
//  dey
//  bpl .rd1
//  ; restore slot ROM state
//  pla
//  bmi +
//  sta $CFFF
//+ cli
//  rts
//.tbl !byte $C5,$3A,$A3,$5C,$C5,$3A,$A3,$5C
//} ; end zone
//end
//
//def getTick()
//  byte timeBuf[8]
//  word tick
//  readNoSlotClock(@timeBuf)
//  tick = (timeBuf[7] & $F) + ((timeBuf[7] >> 4) * 10)
//  tick = tick + ((timeBuf[6] & $F) * 100) + ((timeBuf[6] >> 4) * 1000)
//  return tick + (((timeBuf[5] & $F) % 5) * 6000)
//end
//
//def tickDiff(tStart, tEnd)
//  word diff
//  diff = tEnd - tStart
//  if diff >= 0; return diff; fin
//  return diff + 30000
//end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _rwGame(cmd)
  while TRUE
    if callProRWTS(cmd | RWTS_OPENDIR, @game1_filename, LOAD_SAVE_BUF, HEAP_SIZE) == 0
      break
    fin
    textHome()
    ^$c051
    puts("Insert disk 1")
    rdkey()
    ^$c050
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _saveGame()

  // Perform garbage collection and record the size of the heap so we can restore it correctly
  global=>w_heapSize = mmgr(HEAP_COLLECT, 0) - HEAP_BOTTOM

  // Copy data to main memory, and write it out.
  showMapName("Saving game...")
  memcpy(HEAP_BOTTOM, LOAD_SAVE_BUF, HEAP_SIZE)  // LC to low mem
  _rwGame(RWTS_WRITE)
end

def loadInternal()
  word p_loaded

  // Load data to main memory
  _rwGame(RWTS_READ)

  // Copy the heap up, and init it with the correct size.
  p_loaded = LOAD_SAVE_BUF
  if p_loaded=>w_heapSize < 100 or p_loaded=>w_heapSize > HEAP_SIZE
    fatal("Corrupt game file.")
  fin
  memcpy(LOAD_SAVE_BUF, HEAP_BOTTOM, HEAP_SIZE)  // low mem to LC
  initHeap(p_loaded=>w_heapSize)
  return TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _loadGame()
  setMapWindow()
  clearWindow()
  showMapName("Loading game...")

  // Open the file
  ^$4000 = 0  // so 3D engine knows we overwrite HGR page 2, even if we fail
  if !loadInternal()
    showMapName("Not found.")
    getUpperKey()
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def newGame()
  word playersModule, newGameModule
  initHeap(0) // initially empty heap
  global->b_curAvatar = 0
  mmgr(START_LOAD, 1) // players module and new game module both in partition 1
  playersModule = mmgr(QUEUE_LOAD, MOD_GEN_PLAYERS<<8 | RES_TYPE_MODULE)
  newGameModule = mmgr(QUEUE_LOAD, GS_NEW_GAME<<8 | RES_TYPE_MODULE)
  mmgr(FINISH_LOAD, 0)
  playersModule()=>makeInitialParty()
  newGameModule()()
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def gameExists()
  word p_loaded

  // Load first part of save game into mem... 1 block should be plenty to verify it's real.
  if callProRWTS(RWTS_READ | RWTS_OPENDIR, @game1_filename, LOAD_SAVE_BUF, 512) == 0
    // If heap size is reasonable, assume it's a real save game. (Hash will be checked if the
    // user chooses to actually load the game)
    p_loaded = LOAD_SAVE_BUF
    if p_loaded=>w_heapSize >= 100 and p_loaded=>w_heapSize <= HEAP_SIZE
      return TRUE
    fin
  fin
  return FALSE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _newOrLoadGame(ask)
  byte key

  if !gameExists()
    newGame(); return 1
  fin

  if !ask
    loadInternal()
    return 0
  fin

  textHome()
  ^$c053
  ^$25 = 20
  puts("\n    N)ew game, or L)oad last game? ")

  while TRUE
    key = getUpperKey()
    if key == 'N'
      ^$c052
      newGame()
      return 1
    elsif key == 'L'
      ^$c052
      if loadInternal()
        return 0
      fin
    fin
    beep()
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
