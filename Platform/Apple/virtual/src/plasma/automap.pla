///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2017 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
//////////////////f/////////////////////////////////////////////////////////////////////////////////

include "gamelib.plh"
include "playtype.plh"
include "globalDefs.plh"
include "gen_modules.plh"

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the header.
predef _automap_show()#1
word[] funcTbl = @_automap_show

///////////////////////////////////////////////////////////////////////////////////////////////////
// Definitions used by assembly code
asm _defs
!convtab "../../include/hiBitAscii.ct"
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"
tmp         = $2   ; length 2
pTmp        = $4   ; length 2
pix0        = $6   ; length 1
pix1        = $7   ; length 1
tilePtrs    = $8   ; length 2
tileOff     = $A   ; length 1
nTiles      = $B   ; length 1
pScreen     = $C   ; length 2
pTile       = $E   ; length 2
ysav        = $34
end

///////////////////////////////////////////////////////////////////////////////////////////////////
asm _drawSlice(tilePtrs, nTiles, tileOff, pScreen)#0
  +asmPlasmRet 4
  sta pScreen
  sty pScreen+1
  lda evalStkL+1,x
  sta tileOff
  lda evalStkL+2,x
  sta nTiles
  lda evalStkL+3,x
  sta tilePtrs
  lda evalStkH+3,x
  sta tilePtrs+1

  clc           ; start with even-tile logic

.tileLoop
  ldy #0
  lda (tilePtrs),y
  sta pTile
  inc tilePtrs
  bne +
  inc tilePtrs+1
+ lda (tilePtrs),y
  sta pTile+1
  inc tilePtrs
  bne +
  inc tilePtrs+1
+ ldy tileOff     ; start at correct vertical offset within each tile
  lda (pTile),y
  bcs .oddTile    ; first time even, second time odd, third time even, etc.
.evenTile
  lsr             ; in bit A-0
  ror pix0        ;                    out bit 0
  lsr             ; in bit A-1
  ror pix0        ;                    out bit 1
  lsr             ; in bit A-2 (skip)
  lsr             ; in bit A-3 (skip)
  lsr             ; in bit A-4
  ror pix0        ;                    out bit 2
  lsr             ; in bit A-5
  ror pix0        ;                    out bit 3
                  ; in bit A-6 (skip)
                  ; in bit A-7 (hi skip)
  iny
  lda (pTile),y
  lsr             ; in bit A-8 (skip)
  lsr             ; in bit A-9
  ror pix0        ;                    out bit 4
  lsr             ; in bit A-10
  ror pix0        ;                    out bit 5
  lsr             ; in bit A-11 (skip)
  lsr             ; in bit A-12 (skip)
  lsr             ; in bit A-13
  ror pix0        ;                    out bit 6
  lsr             ; in bit A-14
  ror pix1        ;                    out bit 8 (!)
  lsr             ; in bit A-15 (hibit)
  ror pix0        ;                    out bit 7 (!)
  lda pix0
  sec             ; next iteration, use odd-tile logic

.store
  ldy #0
  sta (pScreen),y
  inc pScreen
  dec nTiles      ; count down tiles done
  bne .tileLoop   ; go until they're all done
  rts             ; finished

.oddTile
  lsr             ; in bit B-0 (skip)
  lsr             ; in bit B-1 (skip)
  lsr             ; in bit B-2
  ror pix1        ;                    out bit 9
  lsr             ; in bit B-3
  ror pix1        ;                    out bit 10
  lsr             ; in bit B-4 (skip)
  lsr             ; in bit B-5 (skip)
  lsr             ; in bit B-6
  ror pix1        ;                    out bit 11
                  ; in bit B-7 (hi skip)
  iny
  lda (pTile),y
  lsr             ; in bit B-8
  ror pix1        ;                    out bit 12
  lsr             ; in bit B-9 (skip)
  lsr             ; in bit B-10 (skip)
  lsr             ; in bit B-11
  ror pix1        ;                    out bit 13
  lsr             ; in bit B-12
  ror pix1        ;                    out bit 14
  lsr             ; in bit B-13 (skip)
  lsr             ; in bit B-14 (skip)
  lsr             ; in bit B-15 (hibit)
  ror pix1        ;                    out bit 15 (hibit)
  lda pix1
  clc             ; next iteration, use even-tile logic
  bcc .store      ; always taken
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _automap_show()#1
  setBigWindow
  clearWindow
  rawDisplayStr("Hello automap")
  getUpperKey
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
