///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2015 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
///////////////////////////////////////////////////////////////////////////////////////////////////

include "gamelib.plh"
include "globalDefs.plh"
include "playtype.plh"
include "gen_images.plh"
include "gen_enemies.plh"
include "gen_modules.plh"
include "combat.plh"

predef _combat_zoneEncounter(s_encZone)#1
word[] funcTbl = @_combat_zoneEncounter

// Combat variables that don't need to be saved in game state
byte nPlayersFighting
byte nEnemiesFighting
byte isFleeing
byte combatDebug

///////////////////////////////////////////////////////////////////////////////////////////////////
def combatPause()#0
  byte key

  pause(global=>w_combatPauseCt)

  // Check for speed-up / slow-down
  key = ^kbd
  if key == (11 + 128) or key == ('-'+128) // up-arrow or minus
    ^kbdStrobe
    global=>w_combatPauseCt = max(100, global=>w_combatPauseCt - addPercent(global=>w_combatPauseCt, 20))
  elsif key == (10 + 128) or key == ('+'+128) // down-arrow or plus
    ^kbdStrobe
    global=>w_combatPauseCt = min(9999, global=>w_combatPauseCt + addPercent(global=>w_combatPauseCt, 20))
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def canFight(p)#1
  return p=>w_health > 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def chooseEnemy(maxDist)#1
  word p
  byte n, n2

  // First, determine how many enemies are within striking distance
  n = 0
  p = global=>p_combatFirst
  while p
    if p->t_type == TYPE_ENEMY and canFight(p) and p->b_enemyAttackRange <= maxDist
      n++
    fin
    p = p=>p_combatNext
  loop

  // If nobody in range, ack!
  if !n; return NULL; fin

  // Pick one of the in-range enemies to attack.
  n2 = rand16() % n
  p = global=>p_combatFirst
  while p
    if p->t_type == TYPE_ENEMY and canFight(p) and p->b_enemyAttackRange <= maxDist
      if n2 == 0; return p; fin
      n2--
    fin
    p = p=>p_combatNext
  loop
  return NULL
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def scanModifiers(pMod, s_match)
  word sum
  sum = 0
  while pMod
    if streqi(pMod=>s_name, s_match)
      sum = sum + pMod=>w_modValue
    fin
    pMod = pMod=>p_nextObj
  loop
  return sum
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def rollPlayerHit(pPlayer, pWeapon, pEnemy, sAction)
  word chance
  byte agil, roll

  // Chance to hit:
  // * agil *4
  // * plus aiming attrib
  // * add in any aiming bonus from the weapon
  // * plus skill modifier for the kind of weapon
  // * clamped to range 5% - 90%
  // * then reduced 1% per 5 feet range beyond 5'
  // * clamped to range 0% - 90%
  agil = pPlayer->b_agility
  if pWeapon
    agil = agil + scanModifiers(pWeapon=>p_modifiers, @S_AGILITY)
  fin
  if combatDebug; displayf3("Agil = %d+%d = %d\n", pPlayer->b_agility, agil - pPlayer->b_agility, agil); fin
  chance = (agil * 4) + pPlayer->b_aiming
  if combatDebug; displayf3("Base chnc = %d*4+%d = %d%%\n", agil, pPlayer->b_aiming, chance); fin
  if pWeapon
    chance = chance + scanModifiers(pWeapon=>p_modifiers, @S_AIMING)
    if combatDebug; displayf1(" weap aim=%d\n", scanModifiers(pWeapon=>p_modifiers, @S_AIMING)); fin
    chance = chance + scanModifiers(pPlayer=>p_skills, pWeapon=>s_itemKind)
    if combatDebug; displayf1(" plyr skill=%d\n", scanModifiers(pPlayer=>p_skills, pWeapon=>s_itemKind)); fin
  fin
  chance = max(5, min(90, chance))
  if combatDebug; displayf1(" rng mod=%d\n", max(0, pEnemy->b_enemyAttackRange - 5) / 5); fin
  chance = max(0, chance - (max(0, pEnemy->b_enemyAttackRange - 5)) / 5))
  if combatDebug; displayf1("Final chnc = %d%%\n", chance); fin

  // See if it's a hit
  roll = rand16() % 100
  if combatDebug; displayf2("Roll=%d Hit=%d\n", roll, abs(roll < chance)); getUpperKey(); fin
  if roll >= chance
    setPlural(0)
    displayf3("\n%s %s at %s but misses.\n", pPlayer=>s_name, sAction, pEnemy=>s_name)
    return FALSE
  fin
  return TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def rollEnemyDodge(pPlayer, pEnemy, sAction)
  // Enemy chance to dodge is taken from their chance to hit divided by 2
  if (rand16() % 100) < (pEnemy->b_chanceToHit / 2)
    setPlural(0)
    displayf3("\n%s %s at %s, ", pPlayer=>s_name, sAction, pEnemy=>s_name)
    displayf1("but %s dodges.\n", pEnemy=>s_name)
    return TRUE
  fin
  return FALSE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def damageEnemy(pPlayer, pEnemy, dmg, sAction)#0
  if combatDebug
    displayf3("\nenemy health: %d-%d=%d\n", pEnemy=>w_health, dmg, pEnemy=>w_health-dmg)
    getUpperKey
  fin
  setPlural(0)
  buildString(@addToString)
  printf3("\n%s %s %s ", pPlayer=>s_name, sAction, pEnemy=>s_name)
  printf1("for %d damage.", dmg)
  if pEnemy=>w_health <= dmg
    pEnemy=>w_health = 0
    printf1(" %s is killed!", pEnemy=>s_name)
    nEnemiesFighting = nEnemiesFighting - 1
  else
    pEnemy=>w_health = pEnemy=>w_health - dmg
  fin
  puts("\n")
  displayStr(finishString(0))
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def playerMelee(pPlayer, pWeapon)#0
  word pEnemy, dmg, sAction, bonus
  byte agil

  // Maybe in the future we'll put this under control of a global script
  sAction = "swings"

  if pWeapon
    pEnemy = chooseEnemy(pWeapon->b_weaponRange)
  else
    pEnemy = chooseEnemy(5) // max distance 5 feet for melee
  fin
  if !pEnemy
    displayf2("\n%s foolishly %s, misses by a mile.\n", pPlayer=>s_name, sAction)
    return
  fin

  if !rollPlayerHit(pPlayer, pWeapon, pEnemy, sAction)
    return
  fin
  if rollEnemyDodge(pPlayer, pEnemy, sAction)
    return
  fin

  if pWeapon
    dmg = pWeapon=>r_meleeDmg
  else
    // If using just fists, damage is nd4+h, where n is hand-to-hand skill + 1
    dmg = encodeDice(scanModifiers(pPlayer=>p_skills, @S_HAND_TO_HAND)+1, 4, 0)
  fin
  if combatDebug; displayf3("Base dmg: %dd%d+%d = ", (dmg>>12) & $F, (dmg >> 8) & $F, dmg & $FF); fin
  dmg = rollDice(dmg)
  if combatDebug; displayf1("%d\n", dmg); fin

  // Damage bonus is:
  // 1% per point of combined player and weapon agility
  // 2% per skill level in the weapon type
  // 5% per point of strength, but only if at least 1 pt in hand-to-hand skill
  // (no contribution of strength)
  // (enemies don't have armor)
  bonus = pPlayer->b_agility
  if combatDebug; displayf1("Dmg bonus:\n agil=%d\n", pPlayer->b_agility); fin
  if pWeapon
    bonus = bonus + scanModifiers(pWeapon=>p_modifiers, @S_AGILITY)
    if combatDebug; displayf1(" weap agil=%d\n", scanModifiers(pWeapon=>p_modifiers, @S_AGILITY)); fin
    bonus = bonus + (scanModifiers(pPlayer=>p_skills, pWeapon=>s_itemKind)*2)
    if combatDebug; displayf1(" plyr skill*2=%d\n", scanModifiers(pPlayer=>p_skills, pWeapon=>s_itemKind)*2); fin
  fin
  if scanModifiers(pPlayer=>p_skills, @S_HAND_TO_HAND)
    bonus = bonus + (pPlayer->b_strength * 5)
    if combatDebug; displayf1("  strngth*5=%d\n", pPlayer->b_strength * 5); fin
  fin
  if combatDebug; displayf1("Final bonus=%d%%\n", bonus); fin
  dmg = dmg + addPercent(dmg, bonus)
  if combatDebug; displayf1("Final dmg=%d\n", dmg); getUpperKey(); fin
  damageEnemy(pPlayer, pEnemy, dmg, sAction)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def playerShoot(pPlayer, pWeapon)#0
  word pEnemy, pSkill, dmg
  word chance
  word sAction
  byte agil, roll

  sAction = pWeapon=>s_combatText

  pEnemy = chooseEnemy(pWeapon->b_weaponRange)
  if !pEnemy
    displayf2("\n%s %s but falls short.\n", pPlayer=>s_name, sAction)
    return
  fin

  // Figure out combined player and weapon agility
  agil = pPlayer->b_agility + scanModifiers(pWeapon=>p_modifiers, @S_AGILITY)

  // Roll for hitting and dodging
  if !rollPlayerHit(pPlayer, pWeapon, pEnemy, sAction)
    return
  fin
  if rollEnemyDodge(pPlayer, pEnemy, sAction)
    return
  fin

  // TODO: consider multi-shot weapons

  // Calculate damage
  if combatDebug
    displayf3("Base dmg: %dd%d+%d = ", (pWeapon=>r_projectileDmg>>12) & $F, (pWeapon=>r_projectileDmg >> 8) & $F, pWeapon=>r_projectileDmg & $FF)
  fin
  dmg = rollDice(pWeapon=>r_projectileDmg)
  if combatDebug; displayf1("%d\n", dmg); fin

  // Damage bonus is:
  // * 1% per point of combined player and weapon agility
  // * 2% per skill level in the weapon type
  // (no contribution of strength)
  // (enemies don't have armor)
  dmg = dmg + addPercent(dmg, agil + scanModifiers(pPlayer=>p_skills, pWeapon=>s_itemKind))
  if combatDebug
    displayf1("dmg bonus:\n agil=%d\n", agil)
    displayf1("  plyr skill=%d\n", scanModifiers(pPlayer=>p_skills, pWeapon=>s_itemKind))
    displayf1("final bonus=%d%%\n", agil + scanModifiers(pPlayer=>p_skills, pWeapon=>s_itemKind))
    displayf1("final dmg=%d\n", dmg)
    getUpperKey()
  fin

  // Okay, do that damage.
  damageEnemy(pPlayer, pEnemy, dmg, sAction)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def playerDodge(pPlayer)#0
  displayf1("\n%s dodges.\n", pPlayer=>s_name)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayOpponents()#0
  word p
  byte count, first
  byte isPlural

  buildString(@addToString)
  puts("You face ")
  first = TRUE
  p = global=>p_enemyGroups
  while p
    if !first
      if p=>p_nextObj
        puts(", ")
      else
        puts(" and ")
      fin
    fin
    first = FALSE
    count = countListFiltered(p=>p_enemies, p_nextObj, @canFight)
    isPlural = (count <> 1)
    if (p=>p_enemies=>r_groupSize == 0)
      printf2("%s at %d'", p=>p_enemies=>s_name, p->b_enemyGroupRange)
    else
      printf3("%d %s at %d'", count, p=>p_enemies=>s_name, p->b_enemyGroupRange)
    fin
    p = p=>p_nextObj
  loop
  puts(".\n")
  displayStr(finishString(isPlural))
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayOption(key, str)#0
  buildString(@addToString)
  printf2("\n  (%c)^T033%s ", key, str)
  rawDisplayStr(finishString(0))
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def minEnemyDist()#1
  word p, p2, anybodyAlive, minDist
  minDist = 9999

  // Process each group
  p = global=>p_enemyGroups
  while p
    p2 = p=>p_enemies
    anybodyAlive = FALSE
    while p2
      if canFight(p2); anybodyAlive = TRUE; fin
      p2 = p2=>p_nextObj
    loop
    if anybodyAlive
      minDist = min(minDist, p->b_enemyGroupRange)
    fin
    p = p=>p_nextObj
  loop
  return minDist
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def playerCombatChoose(pl)#0
  word p, pWeapon
  byte nWeapons, key
  byte canShoot, canReload, canChange, canAdvance
  word cursX, cursY

  // Before we start, save the cursor location so we can
  // later restore it for the next player's choice.
  cursX, cursY = getCursor()

  // Count all weapons and get currently equipped
  canShoot  = FALSE
  canReload = FALSE
  canChange = FALSE
  nWeapons  = 0
  pWeapon   = NULL
  p = pl=>p_items
  while p
    if p->t_type == TYPE_WEAPON
      if p->b_flags & ITEM_FLAG_EQUIP; pWeapon = p; fin
      //nWeapons++ Comment this back in to allow weapon changing
    fin
    p = p=>p_nextObj
  loop

  // Let them know their options
  setCursor(cursX, cursY)
  rawDisplayf1("^D%s", pl=>s_name)
  displayOption('M', "Melee")
  if pWeapon
    if pWeapon->b_clipCurrent
      canShoot = TRUE
      displayOption('S', "Shoot")
    fin
    if pWeapon->b_clipCurrent < pWeapon->b_clipSize
      // TODO: Need to check for enough ammo, and use it up.
      canReload = TRUE
      displayOption('R', "Reload")
    fin
    if nWeapons >= 2
      canChange = TRUE
      displayOption('C', "Chg weapon")
    fin
  fin
  displayOption('D', "Dodge")
  displayOption('F', "Flee")
  canAdvance = minEnemyDist() > 5
  if canAdvance; displayOption('A', "Advance"); fin

  while TRUE
    pl->b_combatChoice = getUpperKey()
    when pl->b_combatChoice
      is 'M'
        return
      is 'F'
        isFleeing = TRUE
        return
      is 'D'
        return
      is 'S'
        if canShoot; return; fin
        break
      is 'R'
        if canReload; return; fin
        break
      is 'C'
        if canChange; return; fin
        break
      is 'A'
        if canAdvance; return; fin
        break
      is '%'
        if global->b_godmode
          clearWindow()
          combatDebug = 1-combatDebug
          rawDisplayf1("Combat debug: %d\n\n", combatDebug)
          return playerCombatChoose(pl)
        fin
        break
    wend
    beep()
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def playerCombatTurn(pl)#0
  word pWeapon, pGroup, pEnemy

  // Get weapon
  pWeapon = pl=>p_items
  while pWeapon
    if pWeapon->t_type == TYPE_WEAPON and pWeapon->b_flags & ITEM_FLAG_EQUIP; break; fin
    pWeapon = pWeapon=>p_nextObj
  loop

  // Execute the player's choice
  when pl->b_combatChoice
    is 'M'
      playerMelee(pl, pWeapon)
      break
    is 'F'
      break
    is 'D'
      playerDodge(pl)
      break
    is 'S'
      playerShoot(pl, pWeapon)
      break
    is 'R'
      pWeapon->b_clipCurrent = pWeapon->b_clipSize
      setPlural(FALSE)
      displayf1("%s has reloaded.\n", pl=>s_name)
      break
    is 'C'
      // Change to next weapon in inventory
      pWeapon->b_flags = pWeapon->b_flags & ~ITEM_FLAG_EQUIP
      repeat
        pWeapon = pWeapon=>p_nextObj
        if not pWeapon; pWeapon = pl=>p_items; fin
      until pWeapon->t_type == TYPE_WEAPON
      pWeapon->b_flags = pWeapon->b_flags | ITEM_FLAG_EQUIP
      setPlural(FALSE)
      displayf2("%s changed to using %s.\n", pl=>s_name, pWeapon=>s_name)
      break
    is 'A'
      // Advance 5 feet
      if minEnemyDist() > 5
        pGroup = global=>p_enemyGroups
        while pGroup
          pGroup->b_enemyGroupRange = pGroup->b_enemyGroupRange - 5
          pEnemy = pGroup=>p_enemies
          while pEnemy
            pEnemy->b_enemyAttackRange = pGroup->b_enemyGroupRange
            pEnemy = pEnemy=>p_nextObj
          loop
          pGroup = pGroup=>p_nextObj
        loop
        displayStr("\nYou move forward 5'.\n")
      else
        displayStr("\nEnemies in your way. You can't move forward.\n")
      fin
      break
  wend
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def enemyCombatTurn(pe)#1
  word pl
  byte roll, dam, needShow

  // Choose a target
  pl = randomFromListFiltered(global=>p_players, p_nextObj, @canFight)
  if !pl; return FALSE; fin

  buildString(@addToString)
  printf3("\n%s %s %s ", pe=>s_name, pe=>s_attackText, pl=>s_name)

  // Roll to hit
  roll = rand16() % 100
  // Dodge skill grants 5% per point chance to dodge any attack
  // Agility grants 5% per point chance to dogge
  // Include armor agility bonus
  // TODO: Cap max dodge % at 90%
  // Dodge checked after hit is rolled
  needShow = FALSE
  if roll <= pe->b_chanceToHit
    dam = rollDice(pe=>r_enemyDmg)
    // TODO: Each point of AC reduces damage 5%
    printf1("and hits for %d damage!", dam)
    pl=>w_health = max(0, pl=>w_health - dam)
    if pl=>w_health == 0
      printf1(" %s is killed!", pl=>s_name)
    fin
    needShow = TRUE
  else
    puts("and misses.")
  fin
  puts("\n")

  displayStr(finishString(0))
  if needShow; showParty(); fin
  return TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def combatInsert(toAdd)#0
  word p, pPrev

  // Find the proper position based on combat order number (keep largest first in the list)
  pPrev = @global=>p_combatFirst
  while TRUE
    p = *pPrev
    if !p; break; fin
    if p->b_combatOrder < toAdd->b_combatOrder; break; fin
    pPrev = p + p_combatNext
  loop

  // Add it right there.
  toAdd=>p_combatNext = *pPrev
  *pPrev = toAdd
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def determineCombatOrder()#0
  word p, p2

  nPlayersFighting = 0
  nEnemiesFighting = 0

  // Do each player character, with random chance based on their agility
  global=>p_combatFirst = NULL
  p = global=>p_players
  while p
    if canFight(p)
      p->b_combatOrder = rand16() % (p->b_agility * 10)
      combatInsert(p)
      if (!(p->b_playerFlags & PLAYER_FLAG_NPC)) // only count real players
        nPlayersFighting = nPlayersFighting + 1
      fin
    fin
    p = p=>p_nextObj
  loop

  // Then all the enemies, with random chance based on their chance to hit.
  p = global=>p_enemyGroups
  while p
    p2 = p=>p_enemies
    while p2
      if canFight(p2)
        p2->b_combatOrder = rand16() % p2->b_chanceToHit
        p2->b_enemyAttackRange = p->b_enemyGroupRange
        combatInsert(p2)
        nEnemiesFighting = nEnemiesFighting + 1
      fin
      p2 = p2=>p_nextObj
    loop
    p = p=>p_nextObj
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def makeEnemyGroup(enemyFunc)#1
  word p, enem, groupSize
  p = mmgr(HEAP_ALLOC, TYPE_ENEMY_GROUP)
  enem = enemyFunc()
  p->b_enemyGroupRange = enem->b_enemyAttackRange
  if enem=>r_groupSize == 0  // handle unique enemies
    groupSize = 1
  else
    groupSize = rollDice(enem=>r_groupSize)
  fin
  addToList(p + p_enemies, enem)
  while groupSize > 1
    addToList(p + p_enemies, enemyFunc())
    groupSize--
  loop

  return p
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def makeRandomGroup(mapCode)#0
  word enemiesModule
  word enemyFunc

  enemiesModule = mmgr(QUEUE_LOAD, MOD_GEN_ENEMIES<<8 | RES_TYPE_MODULE)
  mmgr(FINISH_LOAD, 0)

  global=>p_enemyGroups = NULL
  enemyFunc = randomFromArray(enemiesModule()=>enemies_forZone(mapCode))
  addToList(@global=>p_enemyGroups, makeEnemyGroup(enemyFunc))

  mmgr(FREE_MEMORY, enemiesModule)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def collectLootAndXP()#2
  word group, enemies, gold, xp

  gold = 0
  group = global=>p_enemyGroups
  while group
    enemies = group=>p_enemies
    while enemies
      gold = gold + rollDice(enemies=>r_goldLoot)
      xp = xp + rollDice(enemies=>r_enemyXP)
      enemies = enemies=>p_nextObj
    loop
    group = group=>p_nextObj
  loop
  return gold, xp
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def startCombat(mapCode)#1
  word p, p2, n, s

  // Setup
  isFleeing = FALSE
  combatDebug = FALSE
  makeRandomGroup(mapCode)

  // Display portrait of first group
  setPortrait(global=>p_enemyGroups=>p_enemies->b_image)

  // Clear keyboard stobe, because while wandering the map, the player may have
  // queued up movement keys, which are made obsolete by the surprise of combat.
  ^kbdStrobe

  // We're going to do all our text drawing in window 2. Also, might as well
  // set everything up so that the map gets redrawn when combat finishes.
  setWindow2()
  clearWindow()

  // General intro to the combat situation
  callGlobalFunc(GS_COMBAT_INTRO, 0, 0, 0)

  // Say who we're fighting
  p = global=>p_enemyGroups
  while p
    n = countList(p=>p_enemies)
    setPlural(n <> 1)
    s = callGlobalFunc(GS_ENEMY_INTRO, 0, 0, 0)
    displayf2(s, n, p=>p_enemies=>s_name)
    p = p=>p_nextObj
  loop

  rawDisplayStr("\n\nDo you:\n")
  displayOption('B', "Battle")
  displayOption('F', "Flee")
  while TRUE
    n = getUpperKey()
    if n == 'B'
      displayStr("\n\nBattle!")
      combatPause()
      return 1
    elsif n == 'F'
      displayStr("\n\nFleeing...\n")
      return 0
    // Secret option for testing: instant victory
    elsif n == '#' and global->b_godmode
      displayStr("\n\n")
      return 99
    // Secret option for testing: just die
    elsif n == '*' and global->b_godmode
      displayStr("\n\n")
      return -99
    fin
    beep()
  loop

  return 0 // just to keep compiler happy
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// For cheating in god mode, kill all enemies. This is better than just setting nEnemiesFighting
// to zero, because we'll still get loot.
def killAllEnemies()#0
  word pGroup, pEnemy
  pGroup = global=>p_enemyGroups
  // For every group...
  while pGroup
    pEnemy = pGroup=>p_enemies
    // For every enemy in the group...
    while pEnemy
      pEnemy=>w_health = 0 // kill em
      pEnemy = pEnemy=>p_nextObj
    loop
    pGroup = pGroup=>p_nextObj
  loop

  // Update nEnemiesFighting
  determineCombatOrder()
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def processWin()#0
  word gold, xp
  rawDisplayStr("\n")
  callGlobalFunc(GS_COMBAT_WIN, 0, 0, 0)
  // Grab the loot
  gold, xp = collectLootAndXP()
  if gold > 0
    displayf1("You find %d gold pieces! ", addGold(gold))
  fin
  if xp > 0
    displayf1("You earn %d experience! ", addXP(xp))
  fin
  displayStr("\n(press any key)\n")
  getUpperKey()
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Returns: zero if fled, non-zero if won
def _combat_zoneEncounter(s_encZone)#1
  word p, l, answer

  // Show portrait and threat details, find out if player wants to fight (vs. run)
  answer = startCombat(s_encZone)
  if answer == 99
    killAllEnemies()
  elsif answer == -99
    return answer // special code for death
  elsif !answer
    isFleeing = TRUE
  fin

  // We don't need to actually determine combat order yet, but we do need it to calculate the
  // number of enemies.
  determineCombatOrder()

  // Do each round of combat until player wins, loses, or flees
  while TRUE

    // Tell what the party currently faces
    clearWindow()
    displayOpponents()
    rawDisplayStr("\n")
    callGlobalFunc(GS_COMBAT_PROMPT, 0, 0, 0)
    rawDisplayStr("\n")

    // Get the choice of each player or NPC
    p = global=>p_players
    while p
      if canFight(p) and nEnemiesFighting and !isFleeing
        playerCombatChoose(p)
      fin
      p = p=>p_nextObj
    loop
    clearWindow()

    determineCombatOrder()

    p = global=>p_combatFirst
    while p
      if !nPlayersFighting
        return -99  // special code for death
      elsif !nEnemiesFighting
        processWin()
        // Note: no need to clear heap -- the caller does that.
        return 1
      fin

      if canFight(p)
        when p->t_type
          is TYPE_PLAYER
            if isFleeing
              displayStr("\nYou have fled.")
              // Note: no need to clear heap -- the caller does that.
              return 0
            fin
            playerCombatTurn(p)
            combatPause()
            break
          is TYPE_ENEMY
            if enemyCombatTurn(p); combatPause(); fin
            break
          otherwise
            brk()
        wend
      fin
      p = p=>p_combatNext
    loop
  loop
  return 0 // keep compiler happy
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// initialization code

return @funcTbl
done
