///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2022 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
///////////////////////////////////////////////////////////////////////////////////////////////////

include "gamelib.plh"
include "globalDefs.plh"
include "playtype.plh"
include "diskops.plh"

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the the header.
predef _getGame(pDiskOps)#1
word[] funcTbl = @_getGame

word pDiskOps

byte[] legendos_filename = "LEGENDOS.SYSTEM"

word origChksum_0, origChksum_1
word curChksum_0,  curChksum_1

byte[] S_NOX_FILENAME = "DATA.SAVE.GAME1"

///////////////////////////////////////////////////////////////////////////////////////////////////
// Definitions used by assembly code
asm __defs

; Use hi-bit ASCII for Apple II
!convtab "../../include/hiBitAscii.ct"

; Headers
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"
!source "../../include/prorwts.i"

; General use
tmp         = $2
pTmp        = $4
chksum      = $8 ; 4 bytes
xsav        = $46

end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Calculate a 4-byte checksum of a buffer.
// If doStore=1, store it in *pSum (4 bytes).
// If doStore=0, compare to *pSum (4 bytes), and return zero if equal
asm calcChecksum(doStore, pBuf, nPages, pSum)#0
!zone {
  +asmPlasmNoRet 4
  sta tmp           ; pSum
  sty tmp+1
  lda evalStkL+2,x  ; pBuf
  sta pTmp
  lda evalStkH+2,x
  sta pTmp+1
  lda evalStkL+3,x  ; save doStore flg for later
  pha
  lda evalStkL+1,x  ; nPages
  ldy #0
  ldx #3
- sta chksum,x      ; a-reg still has nPages, fine for consistent init
  dex
  bpl -
  clc

  ldx #$60
  stx 0
  jsr 0

.pag
  pha               ; save # pages left
.quad
  ldx #3
- lda chksum,x
  rol
  adc (pTmp),y
  sta chksum,x
  iny
  dex
  bpl -
  tya
  bne .quad

  inc pTmp+1      ; next page
  pla
  sec
  sbc #1
  bne .pag

  ldy #3
  pla             ; check doStore flg
  beq .chk

.sto
  lda chksum,y
  sta (tmp),y
  dey
  bpl .sto
  rts             ; return val irrelevant for store mode

.chk
  lda chksum,y
  eor (tmp),y
  bne +
  dey
  bpl .chk
+ ldy #0          ; return zero if equal
  rts
} ; end of zone
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def reinserted()#1
  if callProRWTS(RWTS_READ | RWTS_OPENDIR, @S_GAME1_FILENAME, LOAD_SAVE_BUF, HEAP_SIZE) == 0
    calcChecksum(TRUE, LOAD_SAVE_BUF, HEAP_SIZE >> 8, @curChksum_0)
    if curChksum_0 == origChksum_0 and curChksum_1 == origChksum_1
      return TRUE
    fin
  fin
  return FALSE
end

//  // See if there's a Nox game in drive 2.
//  ^LOAD_SAVE_BUF = $AA
//  if callProRWTS(RWTS_READ | RWTS_OPENDIR, "NA", LOAD_SAVE_BUF, 512) == 0
//    printf1("First open succeeded: $%x\n", ^LOAD_SAVE_BUF)
//    rdkey()
//    ^LOAD_SAVE_BUF = $BB
//    if callProRWTS(RWTS_SEEK | RWTS_READDIR, "DATA.SAVE.GAME1", NULL, $C00) == 0
//      printf1("Seek succeeded: $%x\n", ^LOAD_SAVE_BUF)
//      rdkey()
//      ^LOAD_SAVE_BUF = $CC
//      if callProRWTS(RWTS_READ | RWTS_RDWRPART, NULL, LOAD_SAVE_BUF, $200) == 0
//        printf1("Read succeeded: $%x\n", ^LOAD_SAVE_BUF)
//      else
//        puts("Read failed\n")
//      fin
//    else
//      puts("Seek failed\n")
//    fin
//  else
//    puts("First open failed\n")
//  fin
//  rdkey
//  return FALSE

///////////////////////////////////////////////////////////////////////////////////////////////////
def findNox(readOrOpen)#1
  ^LOAD_SAVE_BUF = $AA
  if callProRWTS(RWTS_SEEK | readOrOpen, @S_NOX_FILENAME, NULL, $C00) == 0
    printf1("Seek succeeded: $%x\n", ^LOAD_SAVE_BUF)
    rdkey()
    ^LOAD_SAVE_BUF = $BB
    if callProRWTS(RWTS_READ | RWTS_RDWRPART, NULL, LOAD_SAVE_BUF, $200) == 0
      printf1("Read succeeded: $%x\n", ^LOAD_SAVE_BUF)
      return TRUE
    else
      puts("Read failed\n")
    fin
  else
    puts("Seek failed\n")
  fin
  rdkey
  return FALSE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def printNox()#0
  word len, c, prev

  // Nox fields
  // 
  // $0     - health status - ask Mark what this means
  // $1     - level
  // $2-3   - HP lo/hi
  // $10    - str
  // $11    - dex
  // $12    - int
  // $13    - gender - 0=male, 1=female, 2=other
  // $19    - skill score - melee
  // $1C    - skill score - ranged
  // $1F    - skill score - dodge-parry
  // $22    - skill score - critical hit
  // $25    - skill score - lockpick
  // $28    - skill score - pilfer
  // $2B    - training - melee
  // $2C    - training - ranged
  // $2D    - training - dodge-parry
  // $2E    - training - critical hit
  // $2F    - training - lockpick
  // $30    - training - pilfer
  // $47    - attrib upgrade points
  // $48-49 - hp max lo/hi
  // $4B-59 - character name

  textHome
  printf1("level=%d\n", ^(LOAD_SAVE_BUF+1))
  printf1("strength=%d\n", ^(LOAD_SAVE_BUF+$10))
  printf1("dexterity=%d\n", ^(LOAD_SAVE_BUF+$11))
  printf1("intelligence=%d\n", ^(LOAD_SAVE_BUF+$12))
  printf1("gender=%d\n", ^(LOAD_SAVE_BUF+$13))
  printf1("hp-max=%d\n", *(LOAD_SAVE_BUF+$48))

  len = 0
  prev = 0
  while TRUE
    c = ^(LOAD_SAVE_BUF + $4B + len)
    if c == 0; break; fin
    if c < $A0; break; fin
    c = c & $7F
    // Convert to Title Case:
    // if prev and c are both upper letters, convert this char to lower
    ^($201+len) = (prev >= 'A' and prev <= 'Z' and c >= 'A' and c <= 'Z') ?? c + $20 :: c
    prev = c
    len++
  loop
  ^$200 = len
  printf1("name=%s\n", $200)
  rdkey
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def importNox()#1

  ^$c051
  ^$c054
  textHome

  // Check for a nox game file outside the "NA" subdir
  if !findNox(RWTS_OPENDIR)
    // Check for game file within the "NA" subdir
    if callProRWTS(RWTS_READ | RWTS_OPENDIR, "NA", LOAD_SAVE_BUF, 512) == 0
      puts("Opendir succeeded\n")
      rdkey
      if !findNox(RWTS_READDIR)
        ^$c050
        return FALSE
      fin
    else
      puts("Opendir failed\n")
      rdkey
      ^$c050
      return FALSE
    fin
  fin

  printNox
  ^$c050
  return TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def importLL()#1
  word p_loaded, marksSize, p_marks

  if !pDiskOps=>diskops_gameExists()
    return FALSE
  fin

  // Put game in high mem and check it. Also loads the disk marks into LOAD_SAVE_BUF
  textHome // so that "Heap %" is on non-visible part of the screen
  pDiskOps=>diskops_loadInternal()

  // Keep a copy of the imported disk marks aside in main mem
  marksSize = *LOAD_SAVE_BUF
  p_marks = mmgr(REQUEST_MEMORY, marksSize+2)
  memcpy(LOAD_SAVE_BUF, p_marks, marksSize+2, 0)

  // Make sure the user wants to import this game
  while True
    textHome()
    ^$25 = 19
    printf1("\nGame imported with this main character:\n  ==>  %s  <==\n", global=>p_players=>s_name)
    puts("Re-insert disk 1 and press a key,\nor hit [Esc] to cancel import.")
    if rdkey == $9B // esc
      mmgr(FREE_MEMORY, p_marks)
      // To cancel, we need the original disk back in the drive
      if reinserted; return FALSE; fin
    else
      if reinserted(); break; fin
    fin
  loop

  // Write the imported game data
  memcpy(HEAP_BOTTOM, LOAD_SAVE_BUF, HEAP_SIZE, 0)  // LC to low mem to get the import data back
  rwGame(RWTS_WRITE)

  // Write the imported marks right after the heap data
  callProRWTS(RWTS_WRITE | RWTS_RDWRPART, NULL, p_marks, marksSize+2)
  mmgr(FREE_MEMORY, p_marks)

  // Proceed with normal load
  ^$c052 // no text
  clearWindow
  rawDisplayStr("\n^YLoading...^N")
  return TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Load and display the title screen, set up everything in memory
def _getGame(_pDiskOps)#1
  pDiskOps = _pDiskOps

  // May want to use graphic font someday, but mixed-text mode for now
  ^$c053

  // Record checksum of the original data so we can tell when a different LL game is inserted, and
  // also when the original is re-inserted.
  calcChecksum(TRUE, LOAD_SAVE_BUF, HEAP_SIZE >> 8, @origChksum_0)

  // Find a game to import
  while TRUE
    textHome
    ^$25 = 19
    puts("\nInsert disk for import (in same drive),\nthen press a key, or [Esc] to cancel.")
    if rdkey == $9B // esc
      while TRUE
        if reinserted; break; fin
        textHome
        ^$25 = 19
        puts("\nRe-insert disk 1 and press a key.")
        rdkey
      loop
      ^$c052 // no text
      return FALSE
    fin
    if importNox; break; fin
    if importLL; break; fin
  loop
  ^$c052 // no text
  return TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
