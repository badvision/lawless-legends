///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2017 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
//////////////////f/////////////////////////////////////////////////////////////////////////////////

include "gamelib.plh"
include "playtype.plh"
include "globalDefs.plh"
include "gen_modules.plh"
include "gen_items.plh"

const PAGE_SIZE = 13

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the header.
predef _buyFromStore, _sellToStore
word[] funcTbl = @_buyFromStore, @_sellToStore

word pItemsModule
const MAX_PAGE_ITEMS = 20 // should be plenty
word pageItems[MAX_PAGE_ITEMS]
word pagePrices[MAX_PAGE_ITEMS]

///////////////////////////////////////////////////////////////////////////////////////////////////
// Definitions used by assembly code
asm _defs
!convtab "../../include/hiBitAscii.ct"
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"
tmp         = $2
pTmp        = $4
ysav        = $34
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Multiply 16 bit number by 8-bit ratio, and drop lower 8 bits of result. In effect this scales
// num by the approximate ratio 0=0% .. 128=50% .. 255=99%
asm mulRatio    // params: num, ratio
  +asmPlasm 2
.ratio = evalStkL
.numL  = evalStkL+1
.numH  = evalStkH+1
.numHH = tmp
.accLL = tmp+1
.accL  = pTmp
.accH  = pTmp+1
  lda .ratio,x        ; save ratio
  ldy #0
  sty .numHH          ; zero what will become upper 8 bits of num
  sty .accLL          ; clear accumulation area
  sty .accL
  sty .accH
  ldy #8              ; loop over 8 bits of ratio
- lsr                 ; get next bit
  bcc +               ; skip add if clear
  pha
  clc
  lda .numL,x         ; 24-bit add
  adc .accLL
  sta .accLL
  lda .numH,x
  adc .accL
  sta .accL
  lda .numHH
  adc .accH
  sta .accH
  pla
+ asl .numL,x         ; shift number up
  rol .numH,x
  rol .numHH
  dey                 ; and loop again
  bne -
  ldy .accH           ; final result in Y/A
  lda .accL
  rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Calculate markup on a price, where ratio is an 8.8 fixed-point number. Some approx ratios:
// $0000 = 0%
// $0026 = 15%
// $0080 = 50%
// $0100 = 100%
// $0180 = 150%
def calcMarkup(price, ratio)
  word markup
  markup = 0
  while ratio > 255
    markup = markup + price
    ratio = ratio - 256
  loop
  return markup + mulRatio(price, ratio)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def loadItems()
  mmgr(START_LOAD, 1) // code is in partition 1
  pItemsModule = mmgr(QUEUE_LOAD, MOD_GEN_ITEMS<<8 | RES_TYPE_MODULE)
  mmgr(FINISH_LOAD, 0)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def unloadItems()
  mmgr(FREE_MEMORY, pItemsModule)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayBuyTitle(pageNum, nPages)
  clearWindow()
  // Can't use centering mode on oversize window - font engine can't handle width > 255
  if (nPages > 0)
    rawDisplayf2("^T073Buying (page %d of %d)", pageNum+1, nPages)
  else
    rawDisplayStr("^T108Buying")
  fin
  rawDisplayStr("\n\n^LSel^T025Price^T060Item^L")
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayBuyLine(num, price, name)
  rawDisplayf3("\n%c.^T025%d^T060%s", num + 'A', price, name)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayBuyPage(pItemTbl, markupRatio, pageNum, nPages)
  byte itemNum
  word pFunc, pItem

  displayBuyTitle(pageNum, nPages)
  mmgr(HEAP_COLLECT, 0)

  pFunc = pItemTbl + ((pageNum*PAGE_SIZE) << 1)
  for itemNum = 0 to PAGE_SIZE-1
    if !(*pFunc); break; fin
    pItem = (*pFunc)()
    pageItems[itemNum] = pItem
    pagePrices[itemNum] = max(1, pItem=>w_price + calcMarkup(pItem=>w_price, markupRatio))
    setPlural(FALSE)
    if pItem->t_type == TYPE_STUFF; setPlural(TRUE); fin
    displayBuyLine(itemNum, pagePrices[itemNum], pItem=>s_name)
    pFunc = pFunc + 2
  next

  rawDisplayf1("\n\nBrowse item [A-%c], ", itemNum-1+'A')
  if nPages > 0
    rawDisplayf1("page [1-%d], ", nPages)
  fin
  rawDisplayStr("or [Esc].")
  return itemNum
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def countArray(arr)
  byte count
  for count = 0 to 127
    if !*arr; return count; fin
    arr = arr + 2
  next
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _buyFromStore(storeCode, markupRatio)
  word pItemTbl, choice
  byte nItemsOnPage, pageNum, nPages, redisplay

  setOversizeWindow()

  loadItems()
  pItemTbl = pItemsModule()=>items_forStoreCode(storeCode)

  nPages = (countArray(pItemTbl) + PAGE_SIZE) / PAGE_SIZE
  pageNum = 0

  redisplay = TRUE
  while TRUE
    if redisplay
      nItemsOnPage = displayBuyPage(pItemTbl + ((pageNum*PAGE_SIZE)<<1), markupRatio, pageNum, nPages)
    fin
    choice = getUpperKey()
    redisplay = TRUE
    if choice >= '1' and (choice-'1') < nPages
      pageNum = choice - '1'
    elsif choice >= 'A' and (choice-'A' < nItemsOnPage)
      rawDisplayf1("\nTODO: browse it, maybe buy\n")
      getUpperKey()
    elsif choice == $1B // Esc
      break
    else
      beep()
      redisplay = FALSE
    fin
  loop

  unloadItems()
  mmgr(HEAP_COLLECT, 0)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _sellToStore(storeCode, markdownRatio)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
