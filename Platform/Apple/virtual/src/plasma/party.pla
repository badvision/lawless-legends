///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2015-17 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
///////////////////////////////////////////////////////////////////////////////////////////////////

// Functions we import from the main game loop. If you find there are some over there that aren't
// yet exported, modify this header then add the mechanics at the top of gameloop.pla.
include "gamelib.plh"

// Data structure definitions
include "playtype.plh"

// Global definitions
include "globalDefs.plh"
include "gen_modules.plh"
include "gen_items.plh"
include "godmode.plh"

// Definition of constants for functions exported by this module
include "party.plh"

// Tab positions
const INVLBL_X = 10
const INV_X = 25
const INV_RT = 140

const STAT_X = 174
const STATLBL_X = 182
const STATS_COL_1 = 45
const STATS_COL_2 = 140

const INV_ROWS = (BIGWIN_HEIGHT / 9) - 4

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the header.
predef _showPlayerSheet(player_num)#1
predef _benchPlayer()#1
predef _unbenchPlayer()#1
predef _displayItemStats(pItem1, pItem2)#1
predef _displayItemName(pItem)#1
word[] funcTbl = @_showPlayerSheet, @_benchPlayer, @_unbenchPlayer
word           = @_displayItemStats, @_displayItemName

// Other global variables here

///////////////////////////////////////////////////////////////////////////////////////////////////
def itemByNum(player, num)#1
  word item
  item = player=>p_items
  while num
    item = item=>p_nextObj
    num--
  loop
  return item
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Unequip item kind
def unequip(player, type, kind)#1
  word item

  item = player=>p_items
  while item
    if item->t_type == type
      if (streqi(item=>s_itemKind, kind) or type == TYPE_WEAPON) and item->b_flags & ITEM_FLAG_EQUIP
        item->b_flags = item->b_flags & ~ITEM_FLAG_EQUIP
        break
      fin
    fin
    item = item=>p_nextObj
  loop
  return item
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display title of a column at top but below character name. Optionally append a second string,
// then leave a little vertical space below before beginning the content of the column.
def showColumnTitle(x, title, page, nPages)#0
  rawDisplayf2("^V000\n^J^J^L^J^T%D%s", x, title)
  if nPages > 1
    rawDisplayf2(" - p.%d/%d", page, nPages)
  fin
  rawDisplayStr("^N\n^J^J")
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display inventory list page. Return number of items on page.
def showInventory(player, page, select)#1
  word item
  byte s_item, n_item, n_page, totalPages, first

  s_item = 0
  n_item = 0
  n_page = page * INV_ROWS
  item = player=>p_items
  totalPages = (countList(item)+INV_ROWS-1) / INV_ROWS
  showColumnTitle(INV_X-10, "Inventory", page+1, totalPages)
  if page
    while item and n_item < n_page
      item = item=>p_nextObj
      n_item++
    loop
  fin
  first = TRUE
  while item and n_item < (n_page + INV_ROWS)
    if !first; displayChar('\n'); fin
    first = FALSE

    if item->t_type == TYPE_WEAPON or item->t_type == TYPE_ARMOR
      if item->b_flags & ITEM_FLAG_EQUIP
        rawDisplayStr("*")
      fin
    fin

    rawDisplayf2("^T%D%c.", INVLBL_X, 'A' + s_item)
    s_item++

    rawDisplayf1("^T%D", INV_X)
    _displayItemName(item)
    n_item++
    item = item=>p_nextObj
  loop
  return s_item
end

def numToPlayer(num)#1
  word player
  player = global=>p_players
  while num > 0
    player = player=>p_nextObj
    if !player; break; fin // Not that many players
    num--
  loop
  return player
end

def displayDice(dice)#0
  byte n, d, p
  n = (dice >> 12) & $0F
  d = (dice >> 8) & $0F
  p = dice & $FF
  if (p)
    rightJustifyStr(sprintf3("%dd%d+%d", n, d, p), STAT_X)
  else
    rightJustifyStr(sprintf2("%dd%d", n, d), STAT_X)
  fin
end

def vspace()#0
  rawDisplayStr("^J^J^J^J")
end

// Derived stats like armor, damage, etc.
def showDerived(player)#0
  word weapon, dmg

  //rawDisplayStr("^V023")
  showColumnTitle(STAT_X, "Stats", 0, 0)

  rawDisplayf2("^T%DLevel %d\n", STAT_X-5, player->b_level)
  if player->b_skillPoints
    rawDisplayf2("^T%D%s\n", STAT_X-5, "LEVEL UP!")
  fin
  vspace()

  rightJustifyNum(player=>w_health, STAT_X)
  rawDisplayf2("^T%D%s\n", STATLBL_X, @S_HEALTH)
  rightJustifyNum(player=>w_maxHealth, STAT_X)
  rawDisplayf2("^T%D%s\n", STATLBL_X, @S_MAX_HEALTH)
  vspace()

  rightJustifyNum(player->b_armor, STAT_X)
  rawDisplayf1("^T%DArmor\n", STATLBL_X)

  // Get weapon
  weapon = player=>p_items
  while weapon
    if weapon->t_type == TYPE_WEAPON and weapon->b_flags & ITEM_FLAG_EQUIP; break; fin
    weapon = weapon=>p_nextObj
  loop

  if weapon
    if weapon=>r_projectileDmg
      displayDice(weapon=>r_projectileDmg)
      rawDisplayf1("^T%DProjectile\n", STATLBL_X)
    fin
    dmg = weapon=>r_meleeDmg
  else
    dmg = $01400
  fin
  displayDice(dmg)
  rawDisplayf1("^T%DMelee\n", STATLBL_X)

  vspace()
  rightJustifyNum(player=>w_curXP, STAT_X)
  rawDisplayf2("^T%D%s\n", STATLBL_X, "Current XP")
  rightJustifyNum(player=>w_nextXP, STAT_X)
  rawDisplayf2("^T%D%s\n", STATLBL_X, "Next lvl XP")

  vspace()
  rightJustifyNum(global=>w_gold, STAT_X)
  rawDisplayf1("^T%DParty gold", STATLBL_X)
end

def clearLittleArea(x, y)#0
  setWindow(BIGWIN_TOP+y, BIGWIN_TOP+9+y, BIGWIN_LEFT+x+15, BIGWIN_LEFT+x+30)
  clearWindow()
  setBigWindow()
end

// Display skill value
def displaySkill(player, pSkillNum, py, x, numToBump, str, pVal)#0
  ^py = ^py + 9
  if pSkillNum
    ^pSkillNum = 1 + ^pSkillNum
    if numToBump
      if numToBump+1 <> ^pSkillNum; return; fin
      if player->b_skillPoints and ^pVal < 10
        player->b_skillPoints = player->b_skillPoints - 1
        ^pVal = ^pVal + 1
        clearLittleArea(x, ^py)
      else
        beep
        return
      fin
    fin
    rawDisplayf3("^V%D^T%D%c.", ^py, x, 'A' - 2 + ^pSkillNum)
  else
    rawDisplayf1("^V%D", ^py)
  fin
  rightJustifyNum(^pVal, x+26)
  rawDisplayf2("^T%D%s", x+32, str)
end

// Show aquired skills in lower right panel
def showSkills(player, numToBump)#1
  word skill, skillNum, pSkillNum
  byte y, x1, x2

  // First column: skills
  y = 15
  skillNum = 1
  if player->b_skillPoints
    pSkillNum = @skillNum
    x1 = 10
    x2 = STAT_X - 20
  else
    pSkillNum = NULL
    x1 = 0
    x2 = STAT_X - 30
  fin
  showColumnTitle(25, "Skills", 0, 0)
  displaySkill(player, pSkillNum, @y, x1, numToBump, @S_AIMING, player+b_aiming)
  displaySkill(player, pSkillNum, @y, x1, numToBump, @S_HAND_TO_HAND, player+b_handToHand)
  displaySkill(player, pSkillNum, @y, x1, numToBump, @S_DODGING, player+b_dodging)
  skill = player=>p_skills
  while skill
    displaySkill(player, pSkillNum, @y, x1, numToBump, skill=>s_name, skill+w_modValue)
    skill = skill=>p_nextObj
  loop

  // Second column: attributes
  showColumnTitle(STAT_X-5, "Attributes", 0, 0)
  y = 15
  displaySkill(player, pSkillNum, @y, x2, numToBump, @S_INTELLIGENCE, player+b_intelligence)
  displaySkill(player, pSkillNum, @y, x2, numToBump, @S_STRENGTH, player+b_strength)
  displaySkill(player, pSkillNum, @y, x2, numToBump, @S_AGILITY, player+b_agility)
  displaySkill(player, pSkillNum, @y, x2, numToBump, @S_STAMINA, player+b_stamina)
  displaySkill(player, pSkillNum, @y, x2, numToBump, @S_CHARISMA, player+b_charisma)
  displaySkill(player, pSkillNum, @y, x2, numToBump, @S_SPIRIT, player+b_spirit)
  displaySkill(player, pSkillNum, @y, x2, numToBump, @S_LUCK, player+b_luck)
  y = y + 6
  if numToBump
    clearLittleArea(x2, y+9)
  fin
  displaySkill(player, NULL, @y, x2, 0, "Skill points", player+b_skillPoints)

  if player->c_gender > ' '
    vspace()
    rawDisplayf2("\n^T%D%s", x2+32, "Gender")
    rightJustifyStr(sprintf1("%c", player->c_gender), x2+26)
  fin

  return skillNum-1
end

def clearMenuRect()#0
  setWindow(BIGWIN_BOTTOM-10, BIGWIN_BOTTOM, BIGWIN_LEFT, BIGWIN_RIGHT)
  clearWindow()
  setBigWindow()
  rawDisplayf1("^V%D", BIGWIN_HEIGHT-10)
end

// Display menu for selecting inventory items
def showInvMenu(player, totalItems, itemPage, itemsOnPage)#0
  byte playerCount
  playerCount = countList(global=>p_players)

  clearMenuRect()
  if totalItems > 0
    rawDisplayf1("Item [A-%c], ", itemsOnPage-1+'A')
    if totalItems > INV_ROWS
      rawDisplayStr("Pg [")
      if totalItems > (itemPage + 1) * INV_ROWS
        rawDisplayStr(">")
      fin
      if itemPage
        rawDisplayStr("<")
      fin
      rawDisplayStr("], ")
    fin
  fin

  if playerCount > 1; rawDisplayf1("Plyr [1-%d], ", playerCount); fin

  if player->b_skillPoints > 0
    rawDisplayStr("^ILvl U)p^N, ")
  else
    rawDisplayStr("S)kills, ")
  fin

  rawDisplayStr("[Esc]")
end

// Display menu for selecting inventory items
def showSkillsMenu(player, nSkills)#0
  byte playerCount
  playerCount = countList(global=>p_players)
  clearMenuRect()
  if playerCount > 1; rawDisplayf1("Player [1-%d], ", playerCount); fin
  if player->b_skillPoints
    rawDisplayf1("Spend pt [A-%c], ", nSkills-1+'A')
  fin
  rawDisplayStr("X:Inv or [Esc]")
end

// Display menu for selecting inventory items
def showItemMenu(item)#0
  byte type
  clearMenuRect()
  type = item->t_type
  if type == TYPE_ARMOR or type == TYPE_WEAPON
    rawDisplayStr("E)quip/unequip, ")
  fin
  if type == TYPE_ITEM
    rawDisplayStr("U)se, ")
  fin
  rawDisplayStr("D)estroy or [Esc]")
end

// Equip/unequip an item.
def doEquip(player, item)#0
  if unequip(player, item->t_type, item=>s_itemKind) <> item
    item->b_flags = item->b_flags | ITEM_FLAG_EQUIP
  fin
  calcPlayerArmor(player)
end

// Select an item and use it. Returns item if it needs to be processed by outer loop, else NULL
def doUse(player, item)#1
  if item=>p_modifiers
    if streqi(item=>p_modifiers=>s_name, "health")
      if player=>w_health < player=>w_maxHealth
        player=>w_health = min(player=>w_health + item=>p_modifiers=>w_modValue, player=>w_maxHealth)
        item->b_curUses++
        if item->b_curUses >= item->b_maxUses // all used up
          removeFromList(@player=>p_items, item)
        fin
      fin
      return NULL
    fin
  fin
  return item // general 'use' handled by outer engine, because it might involve graphics
end

// Select an item and drop it. Returns TRUE if anything changed
def doDestroy(player, item)#1
  clearMenuRect()
  rawDisplayStr("Destroy ")
  _displayItemName(item)
  rawDisplayStr(" (Y/N)?")
  if getYN()
    removeFromList(@player=>p_items, item)
    calcPlayerArmor(player)
    return TRUE
  fin
  return FALSE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def clearInvRect()#0
  setWindow(BIGWIN_TOP+9, BIGWIN_BOTTOM-10, BIGWIN_LEFT, INV_RT)
  clearWindow()
  setBigWindow()
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def clearMainRect()#0
  setWindow(BIGWIN_TOP+9, BIGWIN_BOTTOM-10, BIGWIN_LEFT, BIGWIN_RIGHT)
  clearWindow()
  setBigWindow()
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def matchEquipped(player, match)#1
  word item
  item = player=>p_items
  while item
    if (item->t_type == match->t_type) and (item->t_type == TYPE_WEAPON or item->t_type == TYPE_ARMOR)
      if item <> match and (item->b_flags & ITEM_FLAG_EQUIP)
        if item->t_type <> TYPE_ARMOR or (item=>s_itemKind == match=>s_itemKind)
          return item
        fin
      fin
    fin
    item = item=>p_nextObj
  loop
  return NULL
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayItems(pItem1, pItem2)#0
  clearMainRect()
  rawDisplayf1("^V000\n^J^J^L^J^T%DInventory", STATS_COL_1)
  if pItem2
    rawDisplayf1("^T%DEquipped", STATS_COL_2)
  fin
  rawDisplayStr("^N^J^J")
  _displayItemStats(pItem1, pItem2)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def interactWithItem(player, item)#1
  word comp, quantity
  byte sel
  while TRUE
    displayItems(item, matchEquipped(player, item))
    showItemMenu(item)
    sel = getUpperKey()
    rawDisplayf1(" %c\n", sel)
    when sel
      // Equip/unequip player with weapon/armor
      is 'E'
        if item->t_type == TYPE_ARMOR or item->t_type == TYPE_WEAPON
          doEquip(player, item)
          return NULL
        else
          beep
        fin
        break
      // Use an item
      is 'U'
        if item->t_type == TYPE_ITEM
          item = doUse(player, item)
          if item; return item; fin  // general 'use' handled by outer engine, because it might involve graphics
        else
          beep
        fin
        break
      // Destroy an item
      is 'D'
        if doDestroy(player, item); return NULL; fin
        break
      is $1B // Esc
        return NULL
      otherwise beep
    wend
  loop
  return NULL
end

// Show player sheet and accept command. If using an item (not just for stats gain)
// the item is returned; else NULL is returned.
def _showPlayerSheet(player_num)#1  // funcTbl functions always have to return a value
  word player, item
  byte i_page, totalItems, itemsOnPage, redisplay, sel, mode, noRepeatMenu

  setBigWindow()

  i_page = 0
  redisplay = 2
  noRepeatMenu = FALSE
  player = numToPlayer(player_num)
  if player->b_skillPoints
    mode = 'S'  // go straight to level up if applicable
  else
    mode = 'I'  // otherwise default to inventory mode
  fin
  repeat
    player = numToPlayer(player_num)
    if !player; beep; return NULL; fin
    if redisplay >= 2
      clearWindow()
      rawDisplayf1("^Y^I %s ^N\n", player=>s_name)
      redisplay = 1
      totalItems = countList(player=>p_items)
    elsif redisplay > 0
      clearInvRect()
    fin
    if redisplay > 0
      if mode == 'I'
        itemsOnPage = showInventory(player, i_page, 0)
        showDerived(player)
      else // 'S'
        itemsOnPage = showSkills(player, 0)
      fin
      redisplay = 0
    fin

    if !noRepeatMenu
      if mode == 'I'
        showInvMenu(player, totalItems, i_page, itemsOnPage)
      else // 'S'
        showSkillsMenu(player, itemsOnPage)
      fin
    fin
    noRepeatMenu = FALSE

    // Get a key, do something
    sel = getUpperKey()
    when sel
      is '1'
      is '2'
      is '3'
        sel = sel - '1'
        if player_num <> sel and countList(global=>p_players) > sel
          player_num = sel
          i_page = 0
          redisplay = 2
        else
          beep
        fin
      // Next inventory page
      is '>'
      is 21  // right-arrow
        if mode=='I' and totalItems > (i_page + 1) * INV_ROWS
          i_page++
          redisplay = 1
        fin
        break
      // Previous inventory page
      is '<'
      is 8  // left-arrow
        if mode=='I' and i_page
          i_page--
          redisplay = 1
        fin
        break
      // Other operations...
      is '&' // add health cheat
        if global->b_godmode
          player=>w_health = player=>w_health + 50
        fin
        break
      is '$' // add gold cheat
        if global->b_godmode
          addGold(500)
        fin
        break
      is '%' // add item cheat
        if global->b_godmode
          pGodModule=>godmode_addItem(player)
          redisplay = 1
        fin
        break
      is '9' // add player cheat
        if global->b_godmode
          pGodModule=>godmode_addPlayer()
        fin
        break
      is '+' // level up cheat
        if global->b_godmode
          addXP(player=>w_nextXP - player=>w_curXP)
          redisplay = 2
        fin
        break
      is $1B // Esc
        return NULL
      otherwise
        if sel == 'X' and mode <> 'I'
          mode = 'I'
          redisplay = 2
        elsif (sel == 'S' or sel == 'U') and mode <> 'S'
          mode = 'S'
          redisplay = 2
        elsif mode == 'I'
          sel = sel - 'A'
          if sel >= 0 and sel < itemsOnPage
            item = interactWithItem(player, itemByNum(player, sel))
            if item; return item; fin // Use an item
            redisplay = 2
          else
            beep
          fin
        elsif mode == 'S'
          sel = sel - 'A'
          if sel >= 0 and sel < itemsOnPage and player->b_skillPoints
            showSkills(player, sel+1)
            // Redisplay when last pt allocated
            if !player->b_skillPoints
              clearWindow()
              redisplay = 1
            else
              noRepeatMenu = TRUE
            fin
          else
            beep
          fin
        else
          beep
        fin
    wend
  until 0
  return NULL
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display a list of NPCs and allow user to select one.
def selectPlayer(players)#1
  byte n_item
  word player

  // First, display the list
  player = players
  n_item = 0
  while player
    if player->b_playerFlags & PLAYER_FLAG_NPC
      displayf1("\n%c)", 'A' + n_item)
      rawDisplayStr("^T018")
      displayStr(player=>s_name)
      n_item++
    fin
    player = player=>p_nextObj
  loop

  if !n_item
    displayStr("No applicable characters.")
    return NULL
  fin

  // Then get a selection
  rawDisplayStr("\nWhich character?")
  n_item = getUpperKey() - 'A'
  player = players
  while player
    if player->b_playerFlags & PLAYER_FLAG_NPC
      if n_item == 0
        break
      fin
      n_item--
    fin
    player = player=>p_nextObj
  loop
  return player
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Allow user to select an active player, and put them on the bench
def _benchPlayer()#1
  word player
  player = selectPlayer(global=>p_players)
  if player
    removeFromList(@global=>p_players, player)
    addToList(@global=>p_benched, player)
    displayStr("\nDone.")
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Allow user to select a benched player, and put them on the bench
def _unbenchPlayer()#1
  word player
  if countList(global=>p_players) == MAX_PARTY
    displayStr("Party too large.")
    return 0
  fin
  player = selectPlayer(global=>p_benched)
  if player
    removeFromList(@global=>p_benched, player)
    addToList(@global=>p_players, player)
    displayStr("\nDone.")
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def tabTo(cursorX)#0
  rawDisplayf1("^T%D", cursorX)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatDice(encoded)#1
  byte nDice, dieSize, add
  nDice = encoded >> 12
  dieSize = (encoded >> 8) & $F
  add = encoded & $F
  rawDisplayf2("%dd%d", nDice, dieSize)
  if add; rawDisplayf1("+%d", add); fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatNum(num)#1
  rawDisplayf1("%d", num)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatStr(str)#1
  rawDisplayStr(str)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatEquipped(num)#1
  if num == 1
    rawDisplayStr("Y")
  else
    rawDisplayStr("N")
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatAttack(code)#1
  if !code; return 0; fin
  if code == 1
    rawDisplayStr("single")
  elsif code == 2
    rawDisplayStr("double")
  else
    rawDisplayf1("%d-shot", code)
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def byteField(pItem, field)#1
  if pItem
    return ^(pItem + field)
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def equippedField(pItem, field)#1
  if pItem
    if ^(pItem + field) & ITEM_FLAG_EQUIP
      return 1
    else
      return 2
    fin
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def wordField(pItem, field)#1
  if pItem
    return *(pItem + field)
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayTwoCol(fieldName, pItem1, pItem2, field, fieldFunc, formatFunc)#0
  word val1, val2
  val1 = fieldFunc(pItem1, field)
  val2 = fieldFunc(pItem2, field)
  if val1 or val2
    rawDisplayf1("\n%s", fieldName)
    if val1; tabTo(STATS_COL_1); formatFunc(val1); fin
    if val2; tabTo(STATS_COL_2); formatFunc(val2); fin
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayWeaponStats(pItem1, pItem2)#0
  displayTwoCol("Equip'd", pItem1, pItem2, b_flags,         @equippedField, @formatEquipped)
  displayTwoCol("Uses",    pItem1, pItem2, b_maxUses,       @byteField, @formatNum)
  displayTwoCol("Ammo",    pItem1, pItem2, s_ammoKind,      @wordField, @formatStr)
  displayTwoCol("Clip",    pItem1, pItem2, b_clipSize,      @byteField, @formatNum)
  displayTwoCol("Melee",   pItem1, pItem2, r_meleeDmg,      @wordField, @formatDice)
  displayTwoCol("Proj",    pItem1, pItem2, r_projectileDmg, @wordField, @formatDice)
  displayTwoCol("Attack",  pItem1, pItem2, ba_attacks+0,    @byteField, @formatAttack)
  displayTwoCol("Att 2",   pItem1, pItem2, ba_attacks+1,    @byteField, @formatAttack)
  displayTwoCol("Att 3",   pItem1, pItem2, ba_attacks+2,    @byteField, @formatAttack)
  displayTwoCol("Range",   pItem1, pItem2, b_weaponRange,   @byteField, @formatNum)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayArmorStats(pItem1, pItem2)#0
  displayTwoCol("Equip'd", pItem1, pItem2, b_flags,      @equippedField, @formatEquipped)
  displayTwoCol("Uses",    pItem1, pItem2, b_maxUses,    @byteField, @formatNum)
  displayTwoCol("Protec",  pItem1, pItem2, b_armorValue, @byteField, @formatNum)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayStuffStats(pItem1, pItem2)#0
  // Nothing special
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _displayItemStats(pItem1, pItem2)#1
  word pMod1, pMod2

  // First, show the item type and name
  when pItem1->t_type
    is TYPE_ITEM;   rawDisplayStr("\nItem");   break
    is TYPE_WEAPON; rawDisplayStr("\nWeapon"); break
    is TYPE_ARMOR;  rawDisplayStr("\nArmor");  break
    is TYPE_STUFF;  rawDisplayStr("\nSupply"); break
    otherwise fatal("tItem")
  wend
  tabTo(STATS_COL_1); _displayItemName(pItem1)
  if pItem2
    tabTo(STATS_COL_2); _displayItemName(pItem2)
  fin

  // Type-specific attributes
  when pItem1->t_type
    is TYPE_WEAPON; displayWeaponStats(pItem1, pItem2); break
    is TYPE_ARMOR;  displayArmorStats(pItem1, pItem2);  break
    is TYPE_STUFF;  displayStuffStats(pItem1, pItem2);  break
  wend

  // If either item has modifiers, show them
  pMod1 = pItem1=>p_modifiers
  pMod2 = NULL
  if pItem2; pMod2 = pItem2=>p_modifiers; fin
  if pMod1 or pMod2
    rawDisplayStr("\nSpecial")
    while pMod1 or pMod2
      if pMod1
        rawDisplayf3("^T%D%d %s", STATS_COL_1, pMod1=>w_modValue, pMod1=>s_name)
        pMod1 = pMod1=>p_nextObj
      fin
      if pMod2
        rawDisplayf3("^T%D%d %s", STATS_COL_2, pMod2=>w_modValue, pMod2=>s_name)
        pMod2 = pMod2=>p_nextObj
      fin
    loop
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// For non-countable items, display singular name.
// For countable "stuff" (e.g. ammo), display the count and appropriate singular or plural name.
def _displayItemName(pItem)#1
  if pItem->t_type == TYPE_STUFF
    setPlural(pItem=>w_count <> 1)
    rawDisplayf1("%d ", pItem=>w_count)
  else
    setPlural(FALSE)
  fin
  rawDisplayf1("%s", pItem=>s_name) // use displayf to get proper plural processing
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
