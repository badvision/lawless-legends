///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2017 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
//////////////////f/////////////////////////////////////////////////////////////////////////////////

include "gamelib.plh"
include "playtype.plh"
include "globalDefs.plh"
include "gen_modules.plh"

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the header.
predef _automap_show()#1
word[] funcTbl = @_automap_show

word tilePtrs[40]
byte blankTile[32]

///////////////////////////////////////////////////////////////////////////////////////////////////
// Definitions used by assembly code
asm _defs
!convtab "../../include/hiBitAscii.ct"
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"
tmp         = $2   ; length 2
pTmp        = $4   ; length 2
pix0        = $6   ; length 1
pix1        = $7   ; length 1
tilePtrs    = $8   ; length 2
tileOff     = $A   ; length 1
nTiles      = $B   ; length 1
pScreen     = $C   ; length 2
pTile       = $E   ; length 2
ysav        = $34
end

///////////////////////////////////////////////////////////////////////////////////////////////////
asm drawSlice(tilePtrs, nTiles, pScreen)#0
  +asmPlasmNoRet 3

  lda #$60
  sta 0
  jsr 0    ; FOO

  lda #0        ; start at zero tile offset
.row
  sta tileOff
  sty pScreen+1
  lda evalStkL+0,x  ; re-init low byte of screen ptr each row
  sta pScreen
  lda evalStkL+1,x
  sta nTiles
  lda evalStkL+2,x
  sta tilePtrs
  lda evalStkH+2,x
  sta tilePtrs+1
  clc           ; start with even-tile logic
.tileLoop
  ldy #0
  lda (tilePtrs),y
  sta pTile
  inc tilePtrs
  bne +
  inc tilePtrs+1
+ lda (tilePtrs),y
  sta pTile+1
  inc tilePtrs
  bne +
  inc tilePtrs+1
+ ldy tileOff     ; start at correct vertical offset within each tile
  lda (pTile),y
  bcs .oddTile    ; first time even, second time odd, third time even, etc.
.evenTile
  lsr             ; in bit A-0
  ror pix0        ;                    out bit 0
  lsr             ; in bit A-1
  ror pix0        ;                    out bit 1
  lsr             ; in bit A-2 (skip)
  lsr             ; in bit A-3 (skip)
  lsr             ; in bit A-4
  ror pix0        ;                    out bit 2
  lsr             ; in bit A-5
  ror pix0        ;                    out bit 3
                  ; in bit A-6 (skip)
                  ; in bit A-7 (hi skip)
  iny
  lda (pTile),y
  lsr             ; in bit A-8 (skip)
  lsr             ; in bit A-9
  ror pix0        ;                    out bit 4
  lsr             ; in bit A-10
  ror pix0        ;                    out bit 5
  lsr             ; in bit A-11 (skip)
  lsr             ; in bit A-12 (skip)
  lsr             ; in bit A-13
  ror pix0        ;                    out bit 6
  lsr             ; in bit A-14
  ror pix1        ;                    out bit 8 (!)
  lsr             ; in bit A-15 (hibit)
  ror pix0        ;                    out bit 7 (!)
  lda pix0
  sec             ; next iteration, use odd-tile logic

.store
  ldy #0
  sta (pScreen),y
  inc pScreen
  dec nTiles      ; count down tiles done
  bne .tileLoop   ; go until we've done all tiles for the row
  lda pScreen+1
  clc
  adc #4          ; advance to next screen line
  tay
  lda tileOff     ; carry already clear from above
  adc #4          ; advance 2 rows within the tiles (1 we did, 1 skipping for downsize)
  cmp #32         ; until done with all 32 bytes of tiles
  bcc .row
  rts             ; finished

.oddTile
  lsr             ; in bit B-0 (skip)
  lsr             ; in bit B-1 (skip)
  lsr             ; in bit B-2
  ror pix1        ;                    out bit 9
  lsr             ; in bit B-3
  ror pix1        ;                    out bit 10
  lsr             ; in bit B-4 (skip)
  lsr             ; in bit B-5 (skip)
  lsr             ; in bit B-6
  ror pix1        ;                    out bit 11
                  ; in bit B-7 (hi skip)
  iny
  lda (pTile),y
  lsr             ; in bit B-8
  ror pix1        ;                    out bit 12
  lsr             ; in bit B-9 (skip)
  lsr             ; in bit B-10 (skip)
  lsr             ; in bit B-11
  ror pix1        ;                    out bit 13
  lsr             ; in bit B-12
  ror pix1        ;                    out bit 14
  lsr             ; in bit B-13 (skip)
  lsr             ; in bit B-14 (skip)
  lsr             ; in bit B-15 (hibit)
  ror pix1        ;                    out bit 15 (hibit)
  lda pix1
  clc             ; next iteration, use even-tile logic
  bcc .store      ; always taken
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayRow(rowNum, mapRowData, tileTrans, pTileset, width)#0
  byte x, mapRaw, tileNum
  for x = 0 to width-1
    mapRaw = ^(mapRowData + x) & $1F
    if mapRaw
      tileNum = ^(tileTrans + ((mapRaw - 1) << 1))
      tilePtrs[x] = pTileset + ((tileNum-1) << 5)  // 32 bytes per tile in the tileset
    else
      tilePtrs[x] = @blankTile
    fin
  next
  drawSlice(@tilePtrs, width, getScreenLine((rowNum+2)<<3) + 2)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _automap_show()#1
  word pTileset, tileTrans, mapData
  byte nTextures, y, rowSize, numRows

  setBigWindow
  clearWindow

  if !mapIs3D; fatal("TODO: 2D automap"); fin // 2d is more complicated with all its segmenting

  //printf2("pCurMap=$%x tileset=%d\n", pCurMap, ^(pCurMap+3)) // FOO

  // Load the tile set
  mmgr(START_LOAD, curMapPartition)
  pTileset = mmgr(QUEUE_LOAD, (^(pCurMap+3))<<8 | RES_TYPE_TILESET)
  mmgr(FINISH_LOAD, 0)

  // Extract significant pointers from the map blob
  rowSize = ^pCurMap
  numRows = ^(pCurMap+1)
  tileTrans = pCurMap + 4
  nTextures = 0
  while ^(tileTrans + (nTextures<<1))
    nTextures++
  loop
  mapData = tileTrans + (nTextures*3) + 2  // *2 for tilenum+texnum, *1 for texture flags, 2 for zero-terms
  //printf2("mapData=$%x, rowSize=%d\n", mapData, rowSize) // FOO

  // Clear out the blank tile buffer
  memset(@blankTile, 0, 32)

  // Display each row
  for y = 0 to numRows-3  // two sentinel rows, and an extra because zero-indexed.
    // The +1's below are to skip over the sentinel row and column that 3D maps have
    displayRow(y, mapData + ((y+1)*rowSize) + 1, tileTrans, pTileset, rowSize-2)
  next

  getUpperKey

  // And unload the tile set
  mmgr(FREE_MEMORY, pTileset)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
