///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2017 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
//////////////////f/////////////////////////////////////////////////////////////////////////////////

include "gamelib.plh"
include "playtype.plh"
include "globalDefs.plh"
include "gen_modules.plh"
include "gen_items.plh"

const PAGE_SIZE = 15 // (183-10)/9 lines, minus 4 lines for header/footer

const STATS_COL_1 = 45
const STATS_COL_2 = 140

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the header.
predef _buyFromStore, _sellToStore
word[] funcTbl = @_buyFromStore, @_sellToStore

word pItemsModule
const MAX_PAGE_ITEMS = 20 // should be plenty
word pageItems[MAX_PAGE_ITEMS]
word pagePrices[MAX_PAGE_ITEMS]
word pagePlayers[MAX_PAGE_ITEMS]
word pMatchPlayer

///////////////////////////////////////////////////////////////////////////////////////////////////
// Definitions used by assembly code
asm _defs
!convtab "../../include/hiBitAscii.ct"
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"
tmp         = $2
pTmp        = $4
ysav        = $34
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Multiply 16 bit number by 8-bit ratio, and drop lower 8 bits of result. In effect this scales
// num by the approximate ratio 0=0% .. 128=50% .. 255=99%
asm mulRatio    // params: num, ratio
  +asmPlasm 2
.ratio = evalStkL
.numL  = evalStkL+1
.numH  = evalStkH+1
.numHH = tmp
.accLL = tmp+1
.accL  = pTmp
.accH  = pTmp+1
  lda .ratio,x        ; save ratio
  ldy #0
  sty .numHH          ; zero what will become upper 8 bits of num
  sty .accLL          ; clear accumulation area
  sty .accL
  sty .accH
  ldy #8              ; loop over 8 bits of ratio
- lsr                 ; get next bit
  bcc +               ; skip add if clear
  pha
  clc
  lda .numL,x         ; 24-bit add
  adc .accLL
  sta .accLL
  lda .numH,x
  adc .accL
  sta .accL
  lda .numHH
  adc .accH
  sta .accH
  pla
+ asl .numL,x         ; shift number up
  rol .numH,x
  rol .numHH
  dey                 ; and loop again
  bne -
  ldy .accH           ; final result in Y/A
  lda .accL
  rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Calculate markup on a price, where ratio is an 8.8 fixed-point number. Some approx ratios:
// $0000 = 0%
// $0026 = 15%
// $0080 = 50%
// $0100 = 100%
// $0180 = 150%
def calcMarkup(price, ratio)
  word markup
  markup = 0
  while ratio > 255
    markup = markup + price
    ratio = ratio - 256
  loop
  return markup + mulRatio(price, ratio)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def loadItems()
  mmgr(START_LOAD, 1) // code is in partition 1
  pItemsModule = mmgr(QUEUE_LOAD, MOD_GEN_ITEMS<<8 | RES_TYPE_MODULE)
  mmgr(FINISH_LOAD, 0)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def unloadItems()
  mmgr(FREE_MEMORY, pItemsModule)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayBuyTitle(pageNum, nPages)
  clearWindow()
  // Can't use centering mode on oversize window - font engine can't handle width > 255
  rawDisplayStr("^Y^I Buying")
  if (nPages > 1)
    rawDisplayf2(" - p. %d/%d", pageNum+1, nPages)
  fin
  rawDisplayStr(" ^N\n^V014^LBrowse^T046Price^T085Item^L")
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayItemName(pItem)
  setPlural(FALSE)
  if pItem->t_type == TYPE_STUFF; setPlural(pItem=>w_count <> 1); fin
  if pItem=>w_count >= 1
    rawDisplayf1("%d ", pItem=>w_count)
  fin
  rawDisplayf1("%s", pItem=>s_name) // use displayf to get proper plural processing
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayItemLine(num)
  rawDisplayf2("\n  %c.^T046%d^T085", num + 'A', pagePrices[num])
  displayItemName(pageItems[num])
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayBuyPage(pItemTbl, markupRatio, pageNum, nPages)
  byte itemNum
  word pFunc, pItem

  displayBuyTitle(pageNum, nPages)
  mmgr(HEAP_COLLECT, 0)

  pFunc = pItemTbl + ((pageNum*PAGE_SIZE) << 1)
  for itemNum = 0 to PAGE_SIZE-1
    if !(*pFunc); break; fin
    pItem = (*pFunc)()
    pageItems[itemNum] = pItem
    pagePrices[itemNum] = max(1, pItem=>w_price + calcMarkup(pItem=>w_price, markupRatio))
    displayItemLine(itemNum)
    pFunc = pFunc + 2
  next

  rawDisplayf2("\n^V166Gold: %d. Browse [A-%c], ", global=>w_gold, itemNum-1+'A')
  if nPages > 1
    rawDisplayf1("p. [1-%d], ", nPages)
  fin
  rawDisplayStr("or [Esc].")
  return itemNum
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def tabTo(cursorX)
  rawDisplayf1("^T%D", cursorX)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatDice(encoded)
  byte nDice, dieSize, add
  nDice = encoded >> 12
  dieSize = (encoded >> 8) & $F
  add = encoded & $F
  rawDisplayf2("%dd%d", nDice, dieSize)
  if add; rawDisplayf1("+%d", add); fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatNum(num)
  rawDisplayf1("%d", num)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatStr(str)
  rawDisplayStr(str)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatAttack(code)
  if !code; return; fin
  if code == 1
    rawDisplayStr("single")
  elsif code == 2
    rawDisplayStr("double")
  else
    rawDisplayf1("%d-shot", code)
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def byteField(pItem, field)
  if pItem
    return ^(pItem + field)
  else
    return 0
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def wordField(pItem, field)
  if pItem
    return *(pItem + field)
  else
    return 0
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayTwoCol(fieldName, pItem1, pItem2, field, fieldFunc, formatFunc)
  word val1, val2
  val1 = fieldFunc(pItem1, field)
  val2 = fieldFunc(pItem2, field)
  if val1 or val2
    rawDisplayf1("\n%s", fieldName)
    if val1; tabTo(STATS_COL_1); formatFunc(val1); fin
    if val2; tabTo(STATS_COL_2); formatFunc(val2); fin
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayWeaponStats(pItem1, pItem2)
  displayTwoCol("Uses",   pItem1, pItem2, b_maxUses,       @byteField, @formatNum)
  displayTwoCol("Ammo",   pItem1, pItem2, s_ammoKind,      @wordField, @formatStr)
  displayTwoCol("Clip",   pItem1, pItem2, b_clipSize,      @byteField, @formatNum)
  displayTwoCol("Melee",  pItem1, pItem2, r_meleeDmg,      @wordField, @formatDice)
  displayTwoCol("Proj",   pItem1, pItem2, r_projectileDmg, @wordField, @formatDice)
  displayTwoCol("Attack", pItem1, pItem2, ba_attacks+0,    @byteField, @formatAttack)
  displayTwoCol("Att 2",  pItem1, pItem2, ba_attacks+1,    @byteField, @formatAttack)
  displayTwoCol("Att 3",  pItem1, pItem2, ba_attacks+2,    @byteField, @formatAttack)
  displayTwoCol("Range",  pItem1, pItem2, b_weaponRange,   @byteField, @formatNum)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayArmorStats(pItem1, pItem2)
  displayTwoCol("Uses",   pItem1, pItem2, b_maxUses,    @byteField, @formatNum)
  displayTwoCol("Protec", pItem1, pItem2, b_armorValue, @byteField, @formatNum)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayStuffStats(pItem1, pItem2)
  // Nothing special
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayItemStats(pItem1, price, pItem2)
  word pMod1, pMod2

  clearWindow()
  rawDisplayf1("^T108^I Browse ^N\n\n^T%D^LMerchandise^L", STATS_COL_1)
  if pItem2
    rawDisplayf2("^T%D^L%s^L", STATS_COL_2, pMatchPlayer=>s_name)
  fin

  // First, show the item type and name
  when pItem1->t_type
    is TYPE_ITEM;   rawDisplayStr("\nItem");   break
    is TYPE_WEAPON; rawDisplayStr("\nWeapon"); break
    is TYPE_ARMOR;  rawDisplayStr("\nArmor");  break
    is TYPE_STUFF;  rawDisplayStr("\nSupply"); break
    otherwise fatal("tItem")
  wend
  tabTo(STATS_COL_1); displayItemName(pItem1)
  if pItem2
    if pItem1->t_type <> pItem2->t_type; fatal("tMatch"); fin
    tabTo(STATS_COL_2); displayItemName(pItem2)
  fin

  // Type-specific attributes
  when pItem1->t_type
    is TYPE_WEAPON; displayWeaponStats(pItem1, pItem2); break
    is TYPE_ARMOR;  displayArmorStats(pItem1, pItem2);  break
    is TYPE_STUFF;  displayStuffStats(pItem1, pItem2);  break
  wend

  // If either item has modifiers, show them
  pMod1 = pItem1=>p_modifiers
  pMod2 = NULL
  if pItem2; pItem2=>p_modifiers; fin
  if pMod1 or pMod2
    rawDisplayStr("\nSpecial:")
    while pMod1 or pMod2
      if pMod1
        rawDisplayf3("^T%D%d %s", STATS_COL_1, pMod1=>w_modValue, pMod1=>s_name)
        pMod1 = pMod1=>p_nextObj
      fin
      if pMod2
        rawDisplayf3("^T%D%d %s", STATS_COL_2, pMod2=>w_modValue, pMod2=>s_name)
        pMod2 = pMod2=>p_nextObj
      fin
    loop
  fin

  rawDisplayf2("\n\nPrice^T%D%d", STATS_COL_1, price)
  rawDisplayf2("\nAvail^T%D%d", STATS_COL_1, global=>w_gold)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def matchEquipped(pMatch, nSkip)
  word pPlayer, pItem
  pPlayer = global=>p_players
  pMatchPlayer = pPlayer
  while pPlayer
    pItem = pPlayer=>p_items
    while pItem
      if (pItem->t_type == pMatch->t_type) and (pItem->t_type == TYPE_WEAPON or pItem->t_type == TYPE_ARMOR)
        if (pItem->b_flags & ITEM_FLAG_EQUIP)
          if pItem->t_type <> TYPE_ARMOR or (pItem=>s_itemKind == pMatch=>s_itemKind)
            if nSkip == 0
              pMatchPlayer = pPlayer
              return pItem
            fin
            nSkip = nSkip - 1
          fin
        fin
      fin
      pItem = pItem=>p_nextObj
    loop
    pPlayer = pPlayer=>p_nextObj
  loop
  return NULL
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayItemMenu(price, hasNextComp)
  rawDisplayf1("\n\n[Esc]^T%D", STATS_COL_1)
  if price <= global=>w_gold
    rawDisplayStr("B)uy it")
  else
    rawDisplayStr("(too much)")
  fin
  if hasNextComp
    rawDisplayf1("^T%DN)ext compare", STATS_COL_2)
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def askQuantity(nMax)
  word num
  if nMax == 1; return 1; fin
  rawDisplayf1("How many (1-%d)? ", nMax)
  num = parseDec(getStringResponse())
  if num < 0 or num > nMax; return 0; fin
  return num
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def browseItem(num)
  word pItem, price, compSkip, pComp, quantity
  byte sel
  pItem = pageItems[num]
  price = pagePrices[num]
  compSkip = 0
  while TRUE
    displayItemStats(pItem, price, matchEquipped(pItem, compSkip))
    displayItemMenu(price, compSkip or matchEquipped(pItem, 1+compSkip))
    sel = getUpperKey()
    rawDisplayf1(" %c\n", sel)
    quantity = 1
    if sel == 'B' and pItem->t_type == TYPE_STUFF and price <= global=>w_gold
      quantity = global=>w_gold / price
      if pItem=>w_maxCount
        quantity = min(quantity, pItem=>w_maxCount)
      fin
      quantity = askQuantity(quantity)
    fin
    if sel == 'B' and quantity >= 1 and (price*quantity) <= global=>w_gold
      matchEquipped(pItem, compSkip) // to set pMatchPlayer
      pComp = scanForNamedObj(pMatchPlayer=>p_items, pItem=>s_name)
      if pComp
        if pItem->t_type == TYPE_STUFF
          pComp=>w_count = pComp=>w_count + quantity
        else
          rawDisplayStr("\nDuplicate item.")
          beep()
          pause(1000)
          continue
        fin
      else
        addToList(@pMatchPlayer=>p_items, pItem)
      fin
      global=>w_gold = global=>w_gold - (price * quantity)
      if pItem->t_type == TYPE_STUFF
        pItem=>w_count = quantity
      fin
      rawDisplayStr("\nPurchase complete.")
      pause(800)
      break
    elsif sel == 'N' and (compSkip or matchEquipped(pItem, 1+compSkip))
      compSkip++
      if !matchEquipped(pItem, compSkip); compSkip = 0; fin
    elsif sel == $1B // Esc
      break
    else
      beep()
    fin
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def percentToRatio(pct)
  return calcMarkup(pct, 656) // Scale 0..100 to 0..255
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _buyFromStore(storeCode, profitPercent)
  word pItemTbl, choice
  byte nItemsOnPage, pageNum, nPages, redisplay

  loadItems()
  pItemTbl = pItemsModule()=>items_forStoreCode(storeCode)

  setOversizeWindow()

  nPages = (countArray(pItemTbl) + PAGE_SIZE - 1) / PAGE_SIZE
  pageNum = 0

  redisplay = TRUE
  while TRUE
    if redisplay
      nItemsOnPage = displayBuyPage(pItemTbl, percentToRatio(profitPercent), pageNum, nPages)
    fin
    choice = getUpperKey()
    redisplay = TRUE
    if choice >= '1' and (choice-'1') < nPages
      pageNum = choice - '1'
    elsif choice >= 'A' and (choice-'A' < nItemsOnPage)
      browseItem(choice-'A')
    elsif choice == $1B // Esc
      break
    else
      beep()
      redisplay = FALSE
    fin
  loop

  unloadItems()
  mmgr(HEAP_COLLECT, 0)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displaySellTitle(pageNum, nPages)
  clearWindow()
  // Can't use centering mode on oversize window - font engine can't handle width > 255
  rawDisplayStr("^Y^I Selling")
  if (nPages > 1)
    rawDisplayf2(" - p. %d/%d", pageNum+1, nPages)
  fin
  rawDisplayStr(" ^N\n^V014^LSell^T046Amt.^T085Item^L")
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def iterateSellables(skipItems, markdownRatio)
  word pPlayer, pItem, itemsOnPage, totalItems
  byte ok
  itemsOnPage = 0
  totalItems = 0
  pPlayer = global=>p_players
  while pPlayer
    pItem = pPlayer=>p_items
    while pItem
      ok = pItem=>w_price > 0
      if pItem->t_type == TYPE_WEAPON or pItem->t_type == TYPE_ARMOR
        if pItem->b_flags & ITEM_FLAG_EQUIP; ok = FALSE; fin
      fin
      if ok
        if totalItems >= skipItems and itemsOnPage < PAGE_SIZE
          pageItems[itemsOnPage] = pItem
          pagePrices[itemsOnPage] = max(0, pItem=>w_price - calcMarkup(pItem=>w_price, markdownRatio))
          pagePlayers[itemsOnPage] = pPlayer
          displayItemLine(itemsOnPage)
          itemsOnPage++
        fin
        totalItems++
      fin
      pItem = pItem=>p_nextObj
    loop
    pPlayer = pPlayer=>p_nextObj
  loop
  if skipItems == 9999; return totalItems; fin
  return itemsOnPage
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displaySellPage(markdownRatio, pageNum, nPages)
  word nItems
  displaySellTitle(pageNum, nPages)
  nItems = iterateSellables(pageNum * PAGE_SIZE, markdownRatio)
  rawDisplayf2("\n^V166Gold: %d. Sell [A-%c], ", global=>w_gold, nItems-1+'A')
  if nPages > 1
    rawDisplayf1("p. [1-%d], ", nPages)
  fin
  rawDisplayStr("or [Esc].")
  return nItems
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def sellItem(num)
  word pItem, price, quantity

  pItem = pageItems[num]
  price = pagePrices[num]

  clearWindow()

  quantity = 1
  if pItem->t_type == TYPE_STUFF and pItem=>w_count >= 2
    rawDisplayStr("^T108^I Sell ^N\n\nSelling ")
    displayItemName(pItem)
    rawDisplayStr("\n\n")
    quantity = askQuantity(pItem=>w_count)
    if quantity == 0; return; fin
  fin

  global=>w_gold = global=>w_gold + (price * quantity)
  if pItem->t_type == TYPE_STUFF
    pItem=>w_count = pItem=>w_count - quantity
    if pItem=>w_count > 0
      quantity = 0
    fin
  fin

  if quantity > 0
    removeFromList(@pagePlayers=>p_items, pItem)
  fin

  rawDisplayStr("\nSale complete.")
  pause(800)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _sellToStore(profitPercent)
  word pItemTbl, choice
  byte nItemsOnPage, pageNum, totalItems, nPages, redisplay

  totalItems = iterateSellables(9999, 0)
  if totalItems == 0
    scriptDisplayStr("\nNothing to sell.\n")
    pause(800)
    return
  fin

  setOversizeWindow()

  pageNum = 0

  redisplay = TRUE
  while totalItems > 0
    nPages = (totalItems + PAGE_SIZE - 1) / PAGE_SIZE // recalc each time since totalItems changes
    pageNum = min(nPages-1, pageNum)
    if redisplay
      nItemsOnPage = displaySellPage(percentToRatio(profitPercent), pageNum, nPages)
    fin
    choice = getUpperKey()
    redisplay = TRUE
    if choice >= '1' and (choice-'1') < nPages
      pageNum = choice - '1'
    elsif choice >= 'A' and (choice-'A' < nItemsOnPage)
      sellItem(choice-'A')
      totalItems = iterateSellables(9999, 0)
    elsif choice == $1B // Esc
      break
    else
      beep()
      redisplay = FALSE
    fin
  loop

  mmgr(HEAP_COLLECT, 0)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
