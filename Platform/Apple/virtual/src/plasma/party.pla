///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2015-17 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
///////////////////////////////////////////////////////////////////////////////////////////////////

// Functions we import from the main game loop. If you find there are some over there that aren't
// yet exported, modify this header then add the mechanics at the top of gameloop.pla.
include "gamelib.plh"

// Data structure definitions
include "playtype.plh"

// Global definitions
include "globalDefs.plh"
include "gen_modules.plh"
include "gen_items.plh"
include "godmode.plh"

// Definition of constants for functions exported by this module
include "party.plh"

// Type groups
const TYPE_ALL   = $0100
const TYPE_EQUIP = $0101
const TYPE_USE   = $0102
const TYPE_DROP  = $0103

// Tab positions
const CHAR_WND_STAT_X = 30
const CHAR_WND_STATLBL_X = 38
const CHAR_WND_INV_X = 18

const STATS_COL_1 = 45
const STATS_COL_2 = 140

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the header.
predef _doPlayerSheet, _benchPlayer, _unbenchPlayer
predef _displayItemStats, _displayItemName
word[] funcTbl = @_doPlayerSheet, @_benchPlayer, @_unbenchPlayer
word           = @_displayItemStats, @_displayItemName

// Other global variables here

///////////////////////////////////////////////////////////////////////////////////////////////////
// Match item type to group type
def itemMatch(item, group)
  byte type

  type = item->t_type
  when group
    is TYPE_ALL
      return TRUE
      break
    is TYPE_EQUIP
      return type == TYPE_ARMOR or type == TYPE_WEAPON
    is TYPE_USE
      return type == TYPE_ITEM
      break
    is TYPE_DROP
    return type == TYPE_WEAPON or type == TYPE_ARMOR
      break
    otherwise
      return group == type
  wend
end
// Search item num
def itemNum(player, skip, num, select)
  word item

  item = player=>p_items
  while item and skip
    item = item=>p_nextObj
    skip--
  loop
  while item
    if itemMatch(item, select)
      if not num; return item; fin
      num--
    fin
    item = item=>p_nextObj
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Unequip item kind
def unequip(player, type, kind)
  word item

  item = player=>p_items
  while item
    if item->t_type == type
      if (streqi(item=>s_itemKind, kind) or type == TYPE_WEAPON) and item->b_flags & ITEM_FLAG_EQUIP
        item->b_flags = item->b_flags & ~ITEM_FLAG_EQUIP
        return item
      fin
    fin
    item = item=>p_nextObj
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display inventory pane
def showInventory(player, page, rows, select)
  word item
  byte s_item, n_item, n_page, first

  s_item = 0
  n_item = 0
  n_page = page * rows
  item = player=>p_items
  setMapWindow()
  clearWindow()
  rawDisplayStr("^Y^LInventory^N")
  if !select
    if page
      rawDisplayf1("^T008<%d", page)
    fin
    if countList(item) > n_page + rows
      rawDisplayf1("^T108%d>", page+2)
    fin
  fin
  rawDisplayStr("^V012") // leave half-a-line of space
  if page
    while item and n_item < n_page
      item = item=>p_nextObj
      n_item++
    loop
  fin
  first = TRUE
  while item and n_item < (n_page + rows)
    if !first; displayChar('\n'); fin
    first = FALSE
    if itemMatch(item, select)
      displayf1("%c)", 'A' + s_item)
      s_item++
    fin
    rawDisplayf1("^T%D", CHAR_WND_INV_X)
    _displayItemName(item)
    if item->t_type == TYPE_WEAPON or item->t_type == TYPE_ARMOR
      if item->b_flags & ITEM_FLAG_EQUIP
        displayStr(" *")
      fin
    fin
    n_item++
    item = item=>p_nextObj
  loop
  while n_item < (n_page + rows)
    displayChar('\n')
    n_item++
  loop
  return s_item
end

// Display skill value
def displaySkill(str, val, col)
  byte[16] mystr

  strncpy(@mystr, str, 15)
  mystr[1] = charToUpper(mystr[1])
  if col & 1
    rawDisplayStr("^T060")
  else
    displayChar('\n')
  fin
  displayf2("%d %s", val, @mystr)
end

def numToPlayer(num)
  word player
  player = global=>p_players
  while num > 0
    player = player=>p_nextObj
    if !player; return; fin // Not that many players
    num--
  loop
  return player
end

def displayDice(dice)
  if (dice & $0F)
    rawDisplayf3("%dd%d+%d", (dice >> 12) & $0F, (dice >> 8) & $0F, dice & $0F)
  else
    rawDisplayf2("^T010%dd%d", (dice >> 12) & $0F, (dice >> 8) & $0F)
  fin
end

// Show stats in the right panel
def showStats(player)
  word weapon, dmg

  setWindow2()
  clearWindow()
  rawDisplayStr("^Y^LStats^N^V012")
  rightJustifyNum(player=>w_health, CHAR_WND_STAT_X);       rawDisplayf1("^T%DHealth\n", CHAR_WND_STATLBL_X)
  rightJustifyNum(player->b_intelligence, CHAR_WND_STAT_X); rawDisplayf1("^T%DIntelligence\n", CHAR_WND_STATLBL_X)
  rightJustifyNum(player->b_strength, CHAR_WND_STAT_X);     rawDisplayf1("^T%DStrength\n", CHAR_WND_STATLBL_X)
  rightJustifyNum(player->b_agility, CHAR_WND_STAT_X);      rawDisplayf1("^T%DAgility\n", CHAR_WND_STATLBL_X)
  rightJustifyNum(player->b_stamina, CHAR_WND_STAT_X);      rawDisplayf1("^T%DStamina\n", CHAR_WND_STATLBL_X)
  rightJustifyNum(player->b_charisma, CHAR_WND_STAT_X);     rawDisplayf1("^T%DCharisma\n", CHAR_WND_STATLBL_X)
  rightJustifyNum(player->b_spirit, CHAR_WND_STAT_X);       rawDisplayf1("^T%DSpirit\n", CHAR_WND_STATLBL_X)
  rightJustifyNum(player->b_luck, CHAR_WND_STAT_X);         rawDisplayf1("^T%DLuck\n", CHAR_WND_STATLBL_X)
  rightJustifyNum(player->b_armor, CHAR_WND_STAT_X);        rawDisplayf1("^T%DArmor\n", CHAR_WND_STATLBL_X)
  // Get weapon
  weapon = player=>p_items
  while weapon
    if weapon->t_type == TYPE_WEAPON and weapon->b_flags & ITEM_FLAG_EQUIP; break; fin
    weapon = weapon=>p_nextObj
  loop
  if weapon
    dmg = weapon=>r_projectileDmg
  else
    dmg = 0
  fin
  if dmg > 0
    displayDice(dmg)
    rawDisplayf1("^T%DProjectile\n", CHAR_WND_STATLBL_X)
  else
    if weapon
      dmg = weapon=>r_meleeDmg
    else
      dmg = $01400
    fin
    displayDice(dmg)
    rawDisplayf1("^T%DMelee\n", CHAR_WND_STATLBL_X)
  fin
  //rightJustifyNum(global=>w_gold, CHAR_WND_STAT_X);         rawDisplayf1("^T%DGold (party)", CHAR_WND_STATLBL_X)
end

// Show aquired skills in lower right panel
def showSkills(player)
  word skill
  byte col

  setWindow3()
  clearWindow()
  rawDisplayStr("^T040^LSkills^L")
  displaySkill("Aim", player->b_aiming, 0)
  displaySkill("Fists", player->b_handToHand, 1)
  displaySkill("Dodge", player->b_dodging, 0)
  col = 1
  skill = player=>p_skills
  while skill
    displaySkill(skill=>s_name, skill=>w_modValue, col)
    skill = skill=>p_nextObj
    col++
  loop
end

// Show player data
def showMenu(vMap)
  rawDisplayf1("^V%D^T012E)quip, U)se, D)rop", vMap - 9)
end

// Select an item and equip/unequip it. Returns TRUE if anything changed.
def doEquip(player, i_page, i_rows)
  word item
  if showInventory(player, i_page, i_rows, TYPE_EQUIP)
    rawDisplayStr("\n^T032Which item?")
    item = itemNum(player, i_rows * i_page, getUpperKey() - 'A', TYPE_EQUIP)
    if item
      if unequip(player, item->t_type, item=>s_itemKind) <> item
        item->b_flags = item->b_flags | ITEM_FLAG_EQUIP
      fin
      calcPlayerArmor(player)
      return TRUE
    fin
  else
    beep
  fin
  return FALSE
end

// Select an item and use it. Returns item if it needs to be processed by outer loop, else NULL
def doUse(player, i_page, i_rows)
  word item
  if showInventory(player, i_page, i_rows, TYPE_USE)
    rawDisplayStr("\n^T032Which item?")
    item = itemNum(player, i_rows * i_page, getUpperKey() - 'A', TYPE_USE)
    if item
      setWindow2()
      clearWindow()
      if item=>p_modifiers and streqi(item=>p_modifiers=>s_name, "health")
        if player=>w_health < player=>w_maxHealth
          player=>w_health = min(player=>w_health + item=>p_modifiers=>w_modValue, player=>w_maxHealth)
          item->b_curUses++
          if item->b_curUses >= item->b_maxUses // all used up
            removeFromList(@player=>p_items, item)
          fin
        fin
      else
        return item // general 'use' handled by outer engine, because it might involve graphics
      fin
    fin
  else
    beep
  fin
end

// Select an item and drop it. Returns TRUE if anything changed
def doDrop(player, i_page, i_rows)
  word item
  byte n_item, i
  if showInventory(player, i_page, i_rows, TYPE_DROP)
    rawDisplayStr("\n^T032Which item?")
    n_item = getUpperKey() - 'A'
    item = itemNum(player, i_rows * i_page, n_item, TYPE_DROP)
    if item
      clearWindow()
      rawDisplayStr("^T050^LDrop^L\n")
      for i = 0 to n_item
        displayChar('\n')
      next
      rawDisplayStr("\n^T018")
      displayStr(item=>s_name)
      for i = n_item + 3 to i_rows
        displayChar('\n')
      next
      rawDisplayStr("\n^T008Are you sure (Y/N)?")
      if getYN()
        i = countList(player=>p_items)
        removeFromList(@player=>p_items, item)
        if countList(player=>p_items) <> i - 1
          displayStr("remove List error!")
          getUpperKey()
        fin
        calcPlayerArmor(player)
        return TRUE
      fin
    fin
  else
    beep
  fin
  return FALSE
end

// Show player sheet and accept command. If using an item (not just for stats gain)
// the item is returned; else NULL is returned.
def _doPlayerSheet(num)
  word player, item
  word hMap, vMap, i_rows
  byte i_page, redisplay

  setOversizeWindow()
  clearWindow()

  // Get size of inventory pane in chars
  getMapWindow(@hMap, @vMap)
  i_rows = (vMap / 9) - 3  // 9 rows per line; minus 3 lines for header/footer
  i_page = 0
  redisplay = TRUE
  repeat
    player = numToPlayer(num)
    if !player; return; fin // Invalid player
    if redisplay
      // First, display the player's name in the title bar
      showMapName(player=>s_name)
      showStats(player)
      redisplay = FALSE
    fin
    showInventory(player, i_page, i_rows, 0)
    showMenu(vMap)
    // Get a key, do something
    when getUpperKey()
      // Select another player to show
      is '1'; num = 0; i_page = 0; redisplay = TRUE; break
      is '2'; num = 1; i_page = 0; redisplay = TRUE; break
      is '3'; num = 2; i_page = 0; redisplay = TRUE; break
      // Equip player with weapon/armor
      is 'E'
        if doEquip(player, i_page, i_rows); redisplay = TRUE; fin
        break
      // Use an item
      is 'U'
        item = doUse(player, i_page, i_rows)
        if item; return item; fin  // general 'use' handled by outer engine, because it might involve graphics
        redisplay = TRUE
        break
      // Drop an item
      is 'D'
        if doDrop(player, i_page, i_rows); redisplay = TRUE; fin
        break
      // Next inventory page
      is '>'
        if countList(player=>p_items) > (i_page + 1) * i_rows
          i_page++
        fin
        break
      // Previous inventory page
      is '<'
        if i_page
          i_page--
        fin
        break
      // Other operations...
      is '&' // add health cheat
        if global->b_godmode
          player=>w_health = player=>w_health + 50
        fin
        break
      is '$' // add gold cheat
        if global->b_godmode
          addGold(500)
        fin
        break
      is '%' // add item cheat
        if global->b_godmode
          pGodModule=>godmode_addItem(player)
        fin
        break
      is '9' // add player cheat
        if global->b_godmode
          pGodModule=>godmode_addPlayer()
        fin
        break
      // All done
      otherwise return
    wend
  until 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display a list of NPCs and allow user to select one.
def selectPlayer(players)
  byte n_item
  word player

  // First, display the list
  player = players
  n_item = 0
  while player
    if player->b_playerFlags & PLAYER_FLAG_NPC
      displayf1("\n%c)", 'A' + n_item)
      rawDisplayStr("^T018")
      displayStr(player=>s_name)
      n_item++
    fin
    player = player=>p_nextObj
  loop

  if !n_item
    displayStr("No applicable characters.")
    return NULL
  fin

  // Then get a selection
  rawDisplayStr("\nWhich character?")
  n_item = getUpperKey() - 'A'
  player = players
  while player
    if player->b_playerFlags & PLAYER_FLAG_NPC
      if n_item == 0
        break
      fin
      n_item--
    fin
    player = player=>p_nextObj
  loop
  return player
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Allow user to select an active player, and put them on the bench
def _benchPlayer()
  word player
  player = selectPlayer(global=>p_players)
  if player
    removeFromList(@global=>p_players, player)
    addToList(@global=>p_benched, player)
    displayStr("\nDone.")
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Allow user to select a benched player, and put them on the bench
def _unbenchPlayer()
  word player
  if countList(global=>p_players) == MAX_PARTY
    displayStr("Party too large.")
    return
  fin
  player = selectPlayer(global=>p_benched)
  if player
    removeFromList(@global=>p_benched, player)
    addToList(@global=>p_players, player)
    displayStr("\nDone.")
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def tabTo(cursorX)
  rawDisplayf1("^T%D", cursorX)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatDice(encoded)
  byte nDice, dieSize, add
  nDice = encoded >> 12
  dieSize = (encoded >> 8) & $F
  add = encoded & $F
  rawDisplayf2("%dd%d", nDice, dieSize)
  if add; rawDisplayf1("+%d", add); fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatNum(num)
  rawDisplayf1("%d", num)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatStr(str)
  rawDisplayStr(str)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatAttack(code)
  if !code; return; fin
  if code == 1
    rawDisplayStr("single")
  elsif code == 2
    rawDisplayStr("double")
  else
    rawDisplayf1("%d-shot", code)
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def byteField(pItem, field)
  if pItem
    return ^(pItem + field)
  else
    return 0
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def wordField(pItem, field)
  if pItem
    return *(pItem + field)
  else
    return 0
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayTwoCol(fieldName, pItem1, pItem2, field, fieldFunc, formatFunc)
  word val1, val2
  val1 = fieldFunc(pItem1, field)
  val2 = fieldFunc(pItem2, field)
  if val1 or val2
    rawDisplayf1("\n%s", fieldName)
    if val1; tabTo(STATS_COL_1); formatFunc(val1); fin
    if val2; tabTo(STATS_COL_2); formatFunc(val2); fin
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayWeaponStats(pItem1, pItem2)
  displayTwoCol("Uses",   pItem1, pItem2, b_maxUses,       @byteField, @formatNum)
  displayTwoCol("Ammo",   pItem1, pItem2, s_ammoKind,      @wordField, @formatStr)
  displayTwoCol("Clip",   pItem1, pItem2, b_clipSize,      @byteField, @formatNum)
  displayTwoCol("Melee",  pItem1, pItem2, r_meleeDmg,      @wordField, @formatDice)
  displayTwoCol("Proj",   pItem1, pItem2, r_projectileDmg, @wordField, @formatDice)
  displayTwoCol("Attack", pItem1, pItem2, ba_attacks+0,    @byteField, @formatAttack)
  displayTwoCol("Att 2",  pItem1, pItem2, ba_attacks+1,    @byteField, @formatAttack)
  displayTwoCol("Att 3",  pItem1, pItem2, ba_attacks+2,    @byteField, @formatAttack)
  displayTwoCol("Range",  pItem1, pItem2, b_weaponRange,   @byteField, @formatNum)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayArmorStats(pItem1, pItem2)
  displayTwoCol("Uses",   pItem1, pItem2, b_maxUses,    @byteField, @formatNum)
  displayTwoCol("Protec", pItem1, pItem2, b_armorValue, @byteField, @formatNum)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayStuffStats(pItem1, pItem2)
  // Nothing special
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _displayItemStats(pItem1, pItem2)
  word pMod1, pMod2

  // First, show the item type and name
  when pItem1->t_type
    is TYPE_ITEM;   rawDisplayStr("\nItem");   break
    is TYPE_WEAPON; rawDisplayStr("\nWeapon"); break
    is TYPE_ARMOR;  rawDisplayStr("\nArmor");  break
    is TYPE_STUFF;  rawDisplayStr("\nSupply"); break
    otherwise fatal("tItem")
  wend
  tabTo(STATS_COL_1); _displayItemName(pItem1)
  if pItem2
    if pItem1->t_type <> pItem2->t_type; fatal("tMatch"); fin
    tabTo(STATS_COL_2); _displayItemName(pItem2)
  fin

  // Type-specific attributes
  when pItem1->t_type
    is TYPE_WEAPON; displayWeaponStats(pItem1, pItem2); break
    is TYPE_ARMOR;  displayArmorStats(pItem1, pItem2);  break
    is TYPE_STUFF;  displayStuffStats(pItem1, pItem2);  break
  wend

  // If either item has modifiers, show them
  pMod1 = pItem1=>p_modifiers
  pMod2 = NULL
  if pItem2; pMod2 = pItem2=>p_modifiers; fin
  if pMod1 or pMod2
    rawDisplayStr("\nSpecial:")
    while pMod1 or pMod2
      if pMod1
        rawDisplayf3("^T%D%d %s", STATS_COL_1, pMod1=>w_modValue, pMod1=>s_name)
        pMod1 = pMod1=>p_nextObj
      fin
      if pMod2
        rawDisplayf3("^T%D%d %s", STATS_COL_2, pMod2=>w_modValue, pMod2=>s_name)
        pMod2 = pMod2=>p_nextObj
      fin
    loop
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// For non-countable items, display singular name.
// For countable "stuff" (e.g. ammo), display the count and appropriate singular or plural name.
def _displayItemName(pItem)
  if pItem->t_type == TYPE_STUFF
    setPlural(pItem=>w_count <> 1)
    rawDisplayf1("%d ", pItem=>w_count)
  else
    setPlural(FALSE)
  fin
  rawDisplayf1("%s", pItem=>s_name) // use displayf to get proper plural processing
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
