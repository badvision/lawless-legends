///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2017 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
//////////////////f/////////////////////////////////////////////////////////////////////////////////

include "gamelib.plh"
include "playtype.plh"
include "globalDefs.plh"
include "gen_modules.plh"

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the header.
predef _automap_show()#1
word[] funcTbl = @_automap_show

word tilePtrs[40]
byte blankTile[9]

///////////////////////////////////////////////////////////////////////////////////////////////////
// Definitions used by assembly code
asm _defs
!convtab "../../include/hiBitAscii.ct"
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"
!source "../../include/fontEngine.i"
tmp         = $2   ; length 2
pTmp        = $4   ; length 2
tilePtrs    = $6   ; length 2
pTile       = $8   ; length 2
pBlank      = $A   ; length 2
hibits      = $C   ; length 1
nTiles      = $D   ; length 1
prevBits    = $E   ; length 1
unused0F    = $F   ; length 1
linePtrs    = $10  ; length 2*8 = 16
ysav        = $34  ; length 1
end

///////////////////////////////////////////////////////////////////////////////////////////////////
asm drawSlice(pBlank, pScreen, nTiles, tilePtrs)#0
  +asmPlasmNoRet 4
  sta tilePtrs
  sty tilePtrs+1
  lda evalStkL+1,x
  sta nTiles
  lda evalStkL+2,x
  sta pTmp
  lda evalStkH+2,x
  sta pTmp+1
  lda evalStkL+3,x
  sta pBlank
  lda evalStkH+3,x
  sta pBlank+1
  ; Grab the line pointers for all 8 lines
  ldx #0
- lda pTmp
  sta linePtrs,x
  inx
  lda pTmp+1
  sta linePtrs,x
  inx
  jsr NextScreenLine
  cpx #16
  bne -
  ; Process one tile
.tile
  ldy #0
  lda (tilePtrs),y
  sta pTile
  iny
  lda (tilePtrs),y
  sta pTile+1
  lda tilePtrs
  clc
  adc #2
  sta tilePtrs
  bcc +
  inc tilePtrs+1
+ dey
  lda (pTile),y
  sta hibits
  sta (pBlank),y   ; if next tile is blank, match hi bits of this tile
  iny
  ldx #0
  lda linePtrs
  lsr
  bcs .odd
.even
  lda (pTile),y
  iny
  asl
  ror prevBits
  lsr hibits
  ror
  sta (linePtrs,x)
  inc linePtrs,x
  inx
  inx
  cpx #16
  bne .even
  beq .next   ; always taken
.odd
  lda (pTile),y
  iny
  lsr prevBits
  rol
  asl
  lsr hibits
  ror
  sta (linePtrs,x)
  inc linePtrs,x
  inx
  inx
  cpx #16
  bne .odd
.next
  dec nTiles
  bne .tile
  rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayRow(rowNum, mapRowData, tileTrans, pSmallTiles, width)#0
  byte x, mapRaw, tileNum
  for x = 0 to width-1
    mapRaw = ^(mapRowData + x) & $1F
    if mapRaw
      tileNum = ^(tileTrans + ((mapRaw - 1) << 1))
      tilePtrs[x] = pSmallTiles + ((tileNum-1) * 9)  // 9 bytes per reduced tile in the tileset
    else
      tilePtrs[x] = @blankTile
    fin
  next
  drawSlice(@blankTile, getScreenLine((rowNum+2)<<3) + 2, width, @tilePtrs)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _automap_show()#1
  word pTileset, pSmallTiles, tileTrans, mapData
  byte nTextures, y, rowSize, numRows

  setBigWindow
  clearWindow

  if !mapIs3D; fatal("TODO: 2D automap"); fin // 2d is more complicated with all its segmenting

  //printf2("pCurMap=$%x tileset=%d\n", pCurMap, ^(pCurMap+3)) // FOO

  // Load the tile set
  mmgr(START_LOAD, curMapPartition)
  pTileset = mmgr(QUEUE_LOAD, (^(pCurMap+3))<<8 | RES_TYPE_TILESET)
  mmgr(FINISH_LOAD, 0)

  // Figure out where the small tiles reside (at the end of the full size tiles)
  pSmallTiles = pTileset + 1 + ((^pTileset) << 5)

  // Extract significant pointers from the map blob
  rowSize = ^pCurMap
  numRows = ^(pCurMap+1)
  tileTrans = pCurMap + 4
  nTextures = 0
  while ^(tileTrans + (nTextures<<1))
    nTextures++
  loop
  mapData = tileTrans + (nTextures*3) + 2  // *2 for tilenum+texnum, *1 for texture flags, 2 for zero-terms
  //printf2("mapData=$%x, rowSize=%d\n", mapData, rowSize) // FOO

  // Clear out the blank tile buffer
  memset(@blankTile, 0, 9)

  // Display each row
  for y = 0 to numRows-3  // two sentinel rows, and an extra because zero-indexed.
    // The +1's below are to skip over the sentinel row and column that 3D maps have
    displayRow(y, mapData + ((y+1)*rowSize) + 1, tileTrans, pSmallTiles, rowSize-2)
  next

  getUpperKey

  // And unload the tile set
  mmgr(FREE_MEMORY, pTileset)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
