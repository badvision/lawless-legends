///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2015 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
///////////////////////////////////////////////////////////////////////////////////////////////////

include "gamelib.plh"
include "globalDefs.plh"
include "godmode.plh"
include "playtype.plh"
include "gen_images.plh"
include "gen_modules.plh"
include "gen_items.plh"
include "gen_players.plh"
include "gen_flags.plh"

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the the header.
predef _setCheatCmds()#1
predef _addItem(player)#1
predef _addPlayer()#1
word[] funcTbl = @_setCheatCmds, @_addItem, @_addPlayer

asm _defs

; Use hi-bit ASCII for Apple II
!convtab "../../include/hiBitAscii.ct"

; Headers
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"

end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Read a string from the keyboard, turn it into a PLASMA string and return a pointer to the string.
asm readStr()#1
  +asmPlasmRet 0
  bit setROM
  jsr ROM_getln1
  bit setLcRW+lcBank2
  txa
  pha
  beq +
- lda inbuf-1,x
  and #$7F
  sta inbuf,x
  dex
  bne -
+ pla
  sta inbuf,x
  lda #<inbuf
  ldy #>inbuf
  rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def parseDecWithDefault(str, default)#1
  if ^str == 0
    return default
  fin
  return parseDec(str)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def splitScreenMode()#0
  flipToPage1()
  textHome()
  ^$c053
  ^$25 = 19
  crout()
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Godmode cheats
def kbdTeleport()#1
  byte d3, num
  word x, y
  byte dir

  splitScreenMode()
  getPos(@x, @y)
  dir = getDir()
  printf3("Current: X=%d Y=%d Facing=%d\n", x, y, dir)

  printf1("3D [%d]: ", mapIs3D)
  d3 = parseDecWithDefault(readStr(), mapIs3D)
  if d3 > 1; d3 = 1; fin
  printf1("Map [%d]: ", mapNum)
  num = parseDecWithDefault(readStr(), mapNum)
  printf1("X [%d]  : ", x)
  x = parseDecWithDefault(readStr(), x)
  printf1("Y [%d] : ", y)
  y = parseDecWithDefault(readStr(), y)
  printf1("Facing [%d]: ", dir)
  dir = parseDecWithDefault(readStr(), dir)

  ^$c052

  setMap(d3, num, x, y, dir)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def showPos()#1
  word x, y
  byte dir

  splitScreenMode()
  getPos(@x, @y)
  printf2("X=%d Y=%d ", x, y)
  if mapIs3D
    printf3("Facing=%d Sky=%d Ground=%d", getDir(), skyNum, groundNum)
  fin
  puts("\nHit any key.\n")
  getUpperKey()
  ^$c052
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def advPortrait(dir)#1
  while TRUE
    portraitNum = portraitNum + dir
    if portraitNum > PO_LAST
      portraitNum = 1
    elsif portraitNum < 1
      portraitNum = PO_LAST
    fin
    if lookupResourcePart(3, portraitNum); break; fin
  loop
  setPortrait(portraitNum)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def nextPortrait()#1
  return advPortrait(1)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def prevPortrait()#1
  return advPortrait(-1)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def testCombat#1
  word x, y
  getPos(@x, @y)
  checkEncounter(x, y, TRUE)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def printMem()#1
  flipToPage1
  ^$c051
  mmgr(DEBUG_MEM, 0)
  rdkey
  auxMmgr(DEBUG_MEM, 0)
  rdkey
  ^$c050
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to the next sky color (3D only)
def nextSky()#1
  setSky((skyNum + 1) % 18)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to the next ground color (3D only)
def nextGround()#1
  setGround((groundNum + 1) % 18)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Edit flags cheat
def editFlags()#1
  word pModule, funcTbl, flagName, flagNum
  flipToPage1
  ^$c051
  textHome()
  *$4000 = 0 // so renderer knows we messed up the page
  puts("Flags:")
  mmgr(START_LOAD, 1) // code is in partition 1
  pModule = mmgr(QUEUE_LOAD, MOD_GEN_FLAGS<<8 | RES_TYPE_MODULE)
  mmgr(FINISH_LOAD, 0)
  funcTbl = pModule()
  while TRUE
    ^$25 = 0
    crout()
    for flagNum = 0 to NUM_GAME_FLAGS-1
      if flagNum > 0; puts(", "); fin
      flagName = funcTbl=>flags_nameForNumber(flagNum)
      // make sure flag name will fit on line
      if ^$24 + ^flagName > 37; crout(); fin
      ^$32 = $FF // normal mode
      if getGameFlag(flagNum); ^$32 = $3F; fin // inverse mode
      puts(flagName)
      ^$32 = $FF
    next
    puts("\nToggle:          ")
    ^$24 = 8
    flagName = readStr()
    if !^flagName; break; fin
    flagNum = funcTbl=>flags_numberForName(flagName)
    if flagNum < 0; beep; continue; fin
    setGameFlag(flagNum, !getGameFlag(flagNum))
  loop
  ^$c050
  mmgr(FREE_MEMORY, pModule)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _setCheatCmds()#1
  // install cheat commands
  setCmd('T', @kbdTeleport)
  setCmd('P', @showPos)
  setCmd('>', @nextPortrait)
  setCmd('<', @prevPortrait)
  setCmd('!', @testCombat)
  setCmd('Y', @nextSky)
  setCmd('G', @nextGround)
  setCmd('&', @printMem)
  setCmd('^', @editFlags)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Abstract code for adding from a list of things (players, items, etc.)
def selectThing(moduleNum, nThings, nSkip, prompt)#1
  word pModule, funcTbl, nFunc, pFunc, p_thing, n_thing, n2, pstr
  nFunc = -1
  pstr = "%d: %s\n"

  flipToPage1()
  textHome()
  ^$c051

  mmgr(START_LOAD, 1) // code is in partition 1
  pModule = mmgr(QUEUE_LOAD, moduleNum<<8 | RES_TYPE_MODULE)
  mmgr(FINISH_LOAD, 0)
  funcTbl = pModule()

  for n_thing = 1 to nThings
    nFunc = (n_thing-1+nSkip) << 1
    pFunc = *(funcTbl + nFunc)
    p_thing = pFunc()
    printf2(pstr, n_thing, p_thing=>s_name)
    if (n_thing % 22) == 0 or n_thing == nThings
      mmgr(HEAP_COLLECT, 0)
      puts(prompt)
      n2 = parseDecWithDefault(readStr(), 0)
      if n2 >= 1 and n2 <= nThings
        nFunc = (n2-1+nSkip) << 1
        pFunc = *(funcTbl + nFunc)
        p_thing = pFunc()
        printf1("Adding '%s'\n", p_thing=>s_name)
        break
      else
        nFunc = -1
        textHome()
      fin
    elsif moduleNum == MOD_GEN_PLAYERS
      // Players are big, so need collect each time
      mmgr(HEAP_COLLECT, 0)
    fin
  next

  mmgr(FREE_MEMORY, pModule)
  ^$c050
  return nFunc
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Add an item cheat
def _addItem(player)#1
  word funcNum
  funcNum = selectThing(MOD_GEN_ITEMS, NUM_ITEMS, 2, "Add item #: ")
  if funcNum >= 0; giveItemToPlayer(player, funcNum); fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Add a player cheat
def _addPlayer()#1
  word funcNum
  funcNum = selectThing(MOD_GEN_PLAYERS, NUM_PLAYERS, 1, "Add player #: ")
  if funcNum >= 0; addPlayerToParty(funcNum); fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
