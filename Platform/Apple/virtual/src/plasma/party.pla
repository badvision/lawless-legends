///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2015-17 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
///////////////////////////////////////////////////////////////////////////////////////////////////

// Functions we import from the main game loop. If you find there are some over there that aren't
// yet exported, modify this header then add the mechanics at the top of gameloop.pla.
include "gamelib.plh"

// Data structure definitions
include "playtype.plh"

// Global definitions
include "globalDefs.plh"
include "gen_modules.plh"
include "gen_items.plh"
include "godmode.plh"

// Definition of constants for functions exported by this module
include "party.plh"

// Tab positions
const INVLBL_X = 10
const INV_X = 25
const INV_RT = 140
const STAT_X = 174
const STATLBL_X = 182

const STATS_COL_1 = 45
const STATS_COL_2 = 140

const INV_ROWS = (BIGWIN_HEIGHT / 9) - 4

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the header.
predef _doPlayerSheet(player_num)#1
predef _benchPlayer()#1
predef _unbenchPlayer()#1
predef _displayItemStats(pItem1, pItem2)#1
predef _displayItemName(pItem)#1
word[] funcTbl = @_doPlayerSheet, @_benchPlayer, @_unbenchPlayer
word           = @_displayItemStats, @_displayItemName

// Other global variables here

///////////////////////////////////////////////////////////////////////////////////////////////////
def itemByNum(player, num)#1
  word item
  item = player=>p_items
  while num
    item = item=>p_nextObj
    num--
  loop
  return item
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Unequip item kind
def unequip(player, type, kind)#1
  word item

  item = player=>p_items
  while item
    if item->t_type == type
      if (streqi(item=>s_itemKind, kind) or type == TYPE_WEAPON) and item->b_flags & ITEM_FLAG_EQUIP
        item->b_flags = item->b_flags & ~ITEM_FLAG_EQUIP
        break
      fin
    fin
    item = item=>p_nextObj
  loop
  return item
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display title of a column at top but below character name. Optionally append a second string,
// then leave a little vertical space below before beginning the content of the column.
def showColumnTitle(x, title, page, nPages)#0
  rawDisplayf2("^V000\n^J^J^L^J^T%D%s", x, title)
  if nPages > 1
    rawDisplayf2(" - p.%d/%d", page, nPages)
  fin
  rawDisplayStr("^N\n^J^J")
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display inventory list page. Return number of items on page.
def showInventory(player, page, select)#1
  word item
  byte s_item, n_item, n_page, totalPages, first

  s_item = 0
  n_item = 0
  n_page = page * INV_ROWS
  item = player=>p_items
  totalPages = (countList(item)+INV_ROWS-1) / INV_ROWS
  showColumnTitle(INV_X-10, "Inventory", page+1, totalPages)
  if page
    while item and n_item < n_page
      item = item=>p_nextObj
      n_item++
    loop
  fin
  first = TRUE
  while item and n_item < (n_page + INV_ROWS)
    if !first; displayChar('\n'); fin
    first = FALSE

    if item->t_type == TYPE_WEAPON or item->t_type == TYPE_ARMOR
      if item->b_flags & ITEM_FLAG_EQUIP
        rawDisplayStr("*")
      fin
    fin

    rawDisplayf2("^T%D%c.", INVLBL_X, 'A' + s_item)
    s_item++

    rawDisplayf1("^T%D", INV_X)
    _displayItemName(item)
    n_item++
    item = item=>p_nextObj
  loop
  return s_item
end

// Display skill value
def displaySkill(str, val, col)#0
  byte[16] mystr

  strncpy(@mystr, str, 15)
  mystr[1] = charToUpper(mystr[1])
  if col & 1
    rawDisplayStr("^T060")
  else
    displayChar('\n')
  fin
  displayf2("%d %s", val, @mystr)
end

def numToPlayer(num)#1
  word player
  player = global=>p_players
  while num > 0
    player = player=>p_nextObj
    if !player; break; fin // Not that many players
    num--
  loop
  return player
end

def displayDice(dice)#0
  byte n, d, p
  n = (dice >> 12) & $0F
  d = (dice >> 8) & $0F
  p = dice & $FF
  if (p)
    rightJustifyStr(sprintf3("%dd%d+%d", n, d, p), STAT_X)
  else
    rightJustifyStr(sprintf2("%dd%d", n, d), STAT_X)
  fin
end

def vspace()#0
  rawDisplayStr("^J^J^J^J")
end

// Show stats in the right panel
def showStats(player)#0
  word weapon, dmg

  showColumnTitle(STAT_X, "Stats", 0, 0)
  rightJustifyNum(player=>w_health, STAT_X);       rawDisplayf1("^T%DHealth\n", STATLBL_X)
  rightJustifyNum(player=>w_maxHealth, STAT_X);    rawDisplayf1("^T%DMax health\n", STATLBL_X)
  vspace()
  rightJustifyNum(player->b_intelligence, STAT_X); rawDisplayf1("^T%DIntelligence\n", STATLBL_X)
  rightJustifyNum(player->b_strength, STAT_X);     rawDisplayf1("^T%DStrength\n", STATLBL_X)
  rightJustifyNum(player->b_agility, STAT_X);      rawDisplayf1("^T%DAgility\n", STATLBL_X)
  rightJustifyNum(player->b_stamina, STAT_X);      rawDisplayf1("^T%DStamina\n", STATLBL_X)
  rightJustifyNum(player->b_charisma, STAT_X);     rawDisplayf1("^T%DCharisma\n", STATLBL_X)
  rightJustifyNum(player->b_spirit, STAT_X);       rawDisplayf1("^T%DSpirit\n", STATLBL_X)
  rightJustifyNum(player->b_luck, STAT_X);         rawDisplayf1("^T%DLuck\n", STATLBL_X)
  vspace()
  rightJustifyNum(player->b_armor, STAT_X);        rawDisplayf1("^T%DArmor\n", STATLBL_X)
  // Get weapon
  weapon = player=>p_items
  while weapon
    if weapon->t_type == TYPE_WEAPON and weapon->b_flags & ITEM_FLAG_EQUIP; break; fin
    weapon = weapon=>p_nextObj
  loop

  if weapon and weapon=>r_projectileDmg
    displayDice(weapon=>r_projectileDmg)
    rawDisplayf1("^T%DProjectile\n", STATLBL_X)
  fin

  if weapon
    dmg = weapon=>r_meleeDmg
  else
    dmg = $01400
  fin
  displayDice(dmg)
  rawDisplayf1("^T%DMelee\n", STATLBL_X)

  vspace()
  rightJustifyNum(global=>w_gold, STAT_X);         rawDisplayf1("^T%DGold (party)", STATLBL_X)
end

// Show aquired skills in lower right panel
def showSkills(player)#0
  word skill
  byte col

  rawDisplayStr("^T040^LSkills^L")
  displaySkill("Aim", player->b_aiming, 0)
  displaySkill("Fists", player->b_handToHand, 1)
  displaySkill("Dodge", player->b_dodging, 0)
  col = 1
  skill = player=>p_skills
  while skill
    displaySkill(skill=>s_name, skill=>w_modValue, col)
    skill = skill=>p_nextObj
    col++
  loop
end

def clearMenuRect()#0
  setWindow(BIGWIN_BOTTOM-10, BIGWIN_BOTTOM, BIGWIN_LEFT, BIGWIN_RIGHT)
  clearWindow()
  setBigWindow()
  rawDisplayf1("^V%D^T012", BIGWIN_HEIGHT-10)
end

// Display menu for selecting inventory items
def showInvMenu(totalItems, itemPage, itemsOnPage)#0
  clearMenuRect()
  if totalItems > 0
    rawDisplayf1("Item [A-%c], ", itemsOnPage+'A'+1)
    if totalItems > INV_ROWS
      rawDisplayStr("Page [")
      if totalItems > (itemPage + 1) * INV_ROWS
        rawDisplayStr(">")
      fin
      if itemPage
        rawDisplayStr("<")
      fin
      rawDisplayStr("], ")
    fin
  fin
  rawDisplayStr("S)kills, or [Esc]")
end

// Display menu for selecting inventory items
def showItemMenu(item)#0
  byte type
  clearMenuRect()
  type = item->t_type
  if type == TYPE_ARMOR or type == TYPE_WEAPON
    rawDisplayStr("E)quip/unequip, ")
  fin
  if type == TYPE_ITEM
    rawDisplayStr("U)se, ")
  fin
  rawDisplayStr("D)estroy, or [Esc]")
end

// Equip/unequip an item.
def doEquip(player, item)#0
  if unequip(player, item->t_type, item=>s_itemKind) <> item
    item->b_flags = item->b_flags | ITEM_FLAG_EQUIP
  fin
  calcPlayerArmor(player)
end

// Select an item and use it. Returns item if it needs to be processed by outer loop, else NULL
def doUse(player, item)#1
  if item=>p_modifiers and streqi(item=>p_modifiers=>s_name, "health")
    if player=>w_health < player=>w_maxHealth
      player=>w_health = min(player=>w_health + item=>p_modifiers=>w_modValue, player=>w_maxHealth)
      item->b_curUses++
      if item->b_curUses >= item->b_maxUses // all used up
        removeFromList(@player=>p_items, item)
      fin
    fin
    return NULL
  fin
  return item // general 'use' handled by outer engine, because it might involve graphics
end

// Select an item and drop it. Returns TRUE if anything changed
def doDestroy(player, item)#1
  clearMenuRect()
  rawDisplayStr("Destroy ")
  _displayItemName(item)
  rawDisplayStr(" (Y/N)?")
  if getYN()
    removeFromList(@player=>p_items, item)
    calcPlayerArmor(player)
    return TRUE
  fin
  return FALSE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def clearInvRect()#0
  setWindow(BIGWIN_TOP+9, BIGWIN_BOTTOM-10, BIGWIN_LEFT, INV_RT)
  clearWindow()
  setBigWindow()
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def clearMainRect()#0
  setWindow(BIGWIN_TOP+9, BIGWIN_BOTTOM-10, BIGWIN_LEFT, BIGWIN_RIGHT)
  clearWindow()
  setBigWindow()
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def matchEquipped(player, match)#1
  word item
  item = player=>p_items
  while item
    if (item->t_type == match->t_type) and (item->t_type == TYPE_WEAPON or item->t_type == TYPE_ARMOR)
      if item <> match and (item->b_flags & ITEM_FLAG_EQUIP)
        if item->t_type <> TYPE_ARMOR or (item=>s_itemKind == match=>s_itemKind)
          return item
        fin
      fin
    fin
    item = item=>p_nextObj
  loop
  return NULL
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayItems(pItem1, pItem2)#0
  clearMainRect()
  rawDisplayf1("^V000\n^J^J^L^J^T%DInventory", STATS_COL_1)
  if pItem2
    rawDisplayf1("^T%DEquipped", STATS_COL_2)
  fin
  rawDisplayStr("^N^J^J")
  _displayItemStats(pItem1, pItem2)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def interactWithItem(player, item)#1
  word comp, quantity
  byte sel
  while TRUE
    displayItems(item, matchEquipped(player, item))
    showItemMenu(item)
    sel = getUpperKey()
    rawDisplayf1(" %c\n", sel)
    when sel
      // Equip/unequip player with weapon/armor
      is 'E'
        if item->t_type == TYPE_ARMOR or item->t_type == TYPE_WEAPON
          doEquip(player, item)
        else
          beep
        fin
        break
      // Use an item
      is 'U'
        if item->t_type == TYPE_ITEM
          item = doUse(player, item)
          if item; return item; fin  // general 'use' handled by outer engine, because it might involve graphics
        else
          beep
        fin
        break
      // Destroy an item
      is 'D'
        if doDestroy(player, item); return NULL; fin
        break
      is $1B // Esc
        return NULL
      otherwise beep
    wend
  loop
  return NULL
end

// Show player sheet and accept command. If using an item (not just for stats gain)
// the item is returned; else NULL is returned.
def _doPlayerSheet(player_num)#1  // funcTbl functions always have to return a value
  word player, item
  byte i_page, totalItems, itemsOnPage, redisplay, sel

  setBigWindow()

  // Get size of inventory pane in chars: 9 rows per line; minus 4 lines for header/footer
  i_page = 0
  redisplay = 2
  repeat
    player = numToPlayer(player_num)
    if !player; return 0; fin // Invalid player
    if redisplay >= 2
      clearWindow()
      rawDisplayf1("^Y^I %s ^N\n", player=>s_name)
      showStats(player)
      redisplay = 1
      totalItems = countList(player=>p_items)
    fin
    if redisplay > 0
      clearInvRect()
      itemsOnPage = showInventory(player, i_page, 0)
      redisplay = 0
    fin
    showInvMenu(totalItems, i_page, itemsOnPage)

    // Get a key, do something
    sel = getUpperKey()
    rawDisplayf1(" %c\n", sel)
    when sel
      // Select another player to show
      is '1'; player_num = 0; i_page = 0; redisplay = 2; break
      is '2'; player_num = 1; i_page = 0; redisplay = 2; break
      is '3'; player_num = 2; i_page = 0; redisplay = 2; break
      is '>'
      is 21  // right-arrow
        if totalItems > (i_page + 1) * INV_ROWS
          i_page++
          redisplay = 1
        fin
        break
      // Previous inventory page
      is '<'
      is 8  // left-arrow
        if i_page
          i_page--
          redisplay = 1
        fin
        break
      // Other operations...
      is '&' // add health cheat
        if global->b_godmode
          player=>w_health = player=>w_health + 50
        fin
        break
      is '$' // add gold cheat
        if global->b_godmode
          addGold(500)
        fin
        break
      is '%' // add item cheat
        if global->b_godmode
          pGodModule=>godmode_addItem(player)
          redisplay = 1
        fin
        break
      is '9' // add player cheat
        if global->b_godmode
          pGodModule=>godmode_addPlayer()
        fin
        break
      is $1B // Esc
        return 0
      otherwise
        sel = sel - 'A'
        if sel >= 0 and sel < itemsOnPage
          interactWithItem(player, itemByNum(player, sel))
          redisplay = 2
        else
          beep
        fin
    wend
  until 0
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display a list of NPCs and allow user to select one.
def selectPlayer(players)#1
  byte n_item
  word player

  // First, display the list
  player = players
  n_item = 0
  while player
    if player->b_playerFlags & PLAYER_FLAG_NPC
      displayf1("\n%c)", 'A' + n_item)
      rawDisplayStr("^T018")
      displayStr(player=>s_name)
      n_item++
    fin
    player = player=>p_nextObj
  loop

  if !n_item
    displayStr("No applicable characters.")
    return NULL
  fin

  // Then get a selection
  rawDisplayStr("\nWhich character?")
  n_item = getUpperKey() - 'A'
  player = players
  while player
    if player->b_playerFlags & PLAYER_FLAG_NPC
      if n_item == 0
        break
      fin
      n_item--
    fin
    player = player=>p_nextObj
  loop
  return player
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Allow user to select an active player, and put them on the bench
def _benchPlayer()#1
  word player
  player = selectPlayer(global=>p_players)
  if player
    removeFromList(@global=>p_players, player)
    addToList(@global=>p_benched, player)
    displayStr("\nDone.")
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Allow user to select a benched player, and put them on the bench
def _unbenchPlayer()#1
  word player
  if countList(global=>p_players) == MAX_PARTY
    displayStr("Party too large.")
    return 0
  fin
  player = selectPlayer(global=>p_benched)
  if player
    removeFromList(@global=>p_benched, player)
    addToList(@global=>p_players, player)
    displayStr("\nDone.")
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def tabTo(cursorX)#0
  rawDisplayf1("^T%D", cursorX)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatDice(encoded)#1
  byte nDice, dieSize, add
  nDice = encoded >> 12
  dieSize = (encoded >> 8) & $F
  add = encoded & $F
  rawDisplayf2("%dd%d", nDice, dieSize)
  if add; rawDisplayf1("+%d", add); fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatNum(num)#1
  rawDisplayf1("%d", num)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatStr(str)#1
  rawDisplayStr(str)
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatEquipped(num)#1
  if num == 1
    rawDisplayStr("Y")
  else
    rawDisplayStr("N")
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def formatAttack(code)#1
  if !code; return 0; fin
  if code == 1
    rawDisplayStr("single")
  elsif code == 2
    rawDisplayStr("double")
  else
    rawDisplayf1("%d-shot", code)
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def byteField(pItem, field)#1
  if pItem
    return ^(pItem + field)
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def equippedField(pItem, field)#1
  if pItem
    if ^(pItem + field) & ITEM_FLAG_EQUIP
      return 1
    else
      return 2
    fin
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def wordField(pItem, field)#1
  if pItem
    return *(pItem + field)
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayTwoCol(fieldName, pItem1, pItem2, field, fieldFunc, formatFunc)#0
  word val1, val2
  val1 = fieldFunc(pItem1, field)
  val2 = fieldFunc(pItem2, field)
  if val1 or val2
    rawDisplayf1("\n%s", fieldName)
    if val1; tabTo(STATS_COL_1); formatFunc(val1); fin
    if val2; tabTo(STATS_COL_2); formatFunc(val2); fin
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayWeaponStats(pItem1, pItem2)#0
  displayTwoCol("Equip'd", pItem1, pItem2, b_flags,         @equippedField, @formatEquipped)
  displayTwoCol("Uses",    pItem1, pItem2, b_maxUses,       @byteField, @formatNum)
  displayTwoCol("Ammo",    pItem1, pItem2, s_ammoKind,      @wordField, @formatStr)
  displayTwoCol("Clip",    pItem1, pItem2, b_clipSize,      @byteField, @formatNum)
  displayTwoCol("Melee",   pItem1, pItem2, r_meleeDmg,      @wordField, @formatDice)
  displayTwoCol("Proj",    pItem1, pItem2, r_projectileDmg, @wordField, @formatDice)
  displayTwoCol("Attack",  pItem1, pItem2, ba_attacks+0,    @byteField, @formatAttack)
  displayTwoCol("Att 2",   pItem1, pItem2, ba_attacks+1,    @byteField, @formatAttack)
  displayTwoCol("Att 3",   pItem1, pItem2, ba_attacks+2,    @byteField, @formatAttack)
  displayTwoCol("Range",   pItem1, pItem2, b_weaponRange,   @byteField, @formatNum)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayArmorStats(pItem1, pItem2)#0
  displayTwoCol("Equip'd", pItem1, pItem2, b_flags,      @equippedField, @formatEquipped)
  displayTwoCol("Uses",    pItem1, pItem2, b_maxUses,    @byteField, @formatNum)
  displayTwoCol("Protec",  pItem1, pItem2, b_armorValue, @byteField, @formatNum)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def displayStuffStats(pItem1, pItem2)#0
  // Nothing special
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def _displayItemStats(pItem1, pItem2)#1
  word pMod1, pMod2

  // First, show the item type and name
  when pItem1->t_type
    is TYPE_ITEM;   rawDisplayStr("\nItem");   break
    is TYPE_WEAPON; rawDisplayStr("\nWeapon"); break
    is TYPE_ARMOR;  rawDisplayStr("\nArmor");  break
    is TYPE_STUFF;  rawDisplayStr("\nSupply"); break
    otherwise fatal("tItem")
  wend
  tabTo(STATS_COL_1); _displayItemName(pItem1)
  if pItem2
    tabTo(STATS_COL_2); _displayItemName(pItem2)
  fin

  // Type-specific attributes
  when pItem1->t_type
    is TYPE_WEAPON; displayWeaponStats(pItem1, pItem2); break
    is TYPE_ARMOR;  displayArmorStats(pItem1, pItem2);  break
    is TYPE_STUFF;  displayStuffStats(pItem1, pItem2);  break
  wend

  // If either item has modifiers, show them
  pMod1 = pItem1=>p_modifiers
  pMod2 = NULL
  if pItem2; pMod2 = pItem2=>p_modifiers; fin
  if pMod1 or pMod2
    rawDisplayStr("\nSpecial")
    while pMod1 or pMod2
      if pMod1
        rawDisplayf3("^T%D%d %s", STATS_COL_1, pMod1=>w_modValue, pMod1=>s_name)
        pMod1 = pMod1=>p_nextObj
      fin
      if pMod2
        rawDisplayf3("^T%D%d %s", STATS_COL_2, pMod2=>w_modValue, pMod2=>s_name)
        pMod2 = pMod2=>p_nextObj
      fin
    loop
  fin
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// For non-countable items, display singular name.
// For countable "stuff" (e.g. ammo), display the count and appropriate singular or plural name.
def _displayItemName(pItem)#1
  if pItem->t_type == TYPE_STUFF
    setPlural(pItem=>w_count <> 1)
    rawDisplayf1("%d ", pItem=>w_count)
  else
    setPlural(FALSE)
  fin
  rawDisplayf1("%s", pItem=>s_name) // use displayf to get proper plural processing
  return 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
return @funcTbl
done
